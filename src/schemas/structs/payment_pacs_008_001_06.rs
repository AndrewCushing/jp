// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `payment_pacs_008_001_06.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct Pacs_008_001_06 {
    // message fields
    pub FIToFICstmrCdtTrf: ::protobuf::SingularPtrField<FIToFICstmrCdtTrfType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pacs_008_001_06 {
    fn default() -> &'a Pacs_008_001_06 {
        <Pacs_008_001_06 as ::protobuf::Message>::default_instance()
    }
}

impl Pacs_008_001_06 {
    pub fn new() -> Pacs_008_001_06 {
        ::std::default::Default::default()
    }

    // .protobuf.payment.FIToFICstmrCdtTrfType FIToFICstmrCdtTrf = 1;


    pub fn get_FIToFICstmrCdtTrf(&self) -> &FIToFICstmrCdtTrfType {
        self.FIToFICstmrCdtTrf.as_ref().unwrap_or_else(|| <FIToFICstmrCdtTrfType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_FIToFICstmrCdtTrf(&mut self) {
        self.FIToFICstmrCdtTrf.clear();
    }

    pub fn has_FIToFICstmrCdtTrf(&self) -> bool {
        self.FIToFICstmrCdtTrf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FIToFICstmrCdtTrf(&mut self, v: FIToFICstmrCdtTrfType) {
        self.FIToFICstmrCdtTrf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FIToFICstmrCdtTrf(&mut self) -> &mut FIToFICstmrCdtTrfType {
        if self.FIToFICstmrCdtTrf.is_none() {
            self.FIToFICstmrCdtTrf.set_default();
        }
        self.FIToFICstmrCdtTrf.as_mut().unwrap()
    }

    // Take field
    pub fn take_FIToFICstmrCdtTrf(&mut self) -> FIToFICstmrCdtTrfType {
        self.FIToFICstmrCdtTrf.take().unwrap_or_else(|| FIToFICstmrCdtTrfType::new())
    }
}

impl ::protobuf::Message for Pacs_008_001_06 {
    fn is_initialized(&self) -> bool {
        for v in &self.FIToFICstmrCdtTrf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.FIToFICstmrCdtTrf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.FIToFICstmrCdtTrf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.FIToFICstmrCdtTrf.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pacs_008_001_06 {
        Pacs_008_001_06::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FIToFICstmrCdtTrfType>>(
                "FIToFICstmrCdtTrf",
                |m: &Pacs_008_001_06| { &m.FIToFICstmrCdtTrf },
                |m: &mut Pacs_008_001_06| { &mut m.FIToFICstmrCdtTrf },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pacs_008_001_06>(
                "Pacs_008_001_06",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pacs_008_001_06 {
        static instance: ::protobuf::rt::LazyV2<Pacs_008_001_06> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pacs_008_001_06::new)
    }
}

impl ::protobuf::Clear for Pacs_008_001_06 {
    fn clear(&mut self) {
        self.FIToFICstmrCdtTrf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pacs_008_001_06 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pacs_008_001_06 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FIToFICstmrCdtTrfType {
    // message fields
    pub GrpHdr: ::protobuf::SingularPtrField<GrpHdrType>,
    pub CdtTrfTxInf: ::protobuf::SingularPtrField<CdtTrfTxInfType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FIToFICstmrCdtTrfType {
    fn default() -> &'a FIToFICstmrCdtTrfType {
        <FIToFICstmrCdtTrfType as ::protobuf::Message>::default_instance()
    }
}

impl FIToFICstmrCdtTrfType {
    pub fn new() -> FIToFICstmrCdtTrfType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.GrpHdrType GrpHdr = 1;


    pub fn get_GrpHdr(&self) -> &GrpHdrType {
        self.GrpHdr.as_ref().unwrap_or_else(|| <GrpHdrType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_GrpHdr(&mut self) {
        self.GrpHdr.clear();
    }

    pub fn has_GrpHdr(&self) -> bool {
        self.GrpHdr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_GrpHdr(&mut self, v: GrpHdrType) {
        self.GrpHdr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_GrpHdr(&mut self) -> &mut GrpHdrType {
        if self.GrpHdr.is_none() {
            self.GrpHdr.set_default();
        }
        self.GrpHdr.as_mut().unwrap()
    }

    // Take field
    pub fn take_GrpHdr(&mut self) -> GrpHdrType {
        self.GrpHdr.take().unwrap_or_else(|| GrpHdrType::new())
    }

    // .protobuf.payment.CdtTrfTxInfType CdtTrfTxInf = 2;


    pub fn get_CdtTrfTxInf(&self) -> &CdtTrfTxInfType {
        self.CdtTrfTxInf.as_ref().unwrap_or_else(|| <CdtTrfTxInfType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_CdtTrfTxInf(&mut self) {
        self.CdtTrfTxInf.clear();
    }

    pub fn has_CdtTrfTxInf(&self) -> bool {
        self.CdtTrfTxInf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CdtTrfTxInf(&mut self, v: CdtTrfTxInfType) {
        self.CdtTrfTxInf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CdtTrfTxInf(&mut self) -> &mut CdtTrfTxInfType {
        if self.CdtTrfTxInf.is_none() {
            self.CdtTrfTxInf.set_default();
        }
        self.CdtTrfTxInf.as_mut().unwrap()
    }

    // Take field
    pub fn take_CdtTrfTxInf(&mut self) -> CdtTrfTxInfType {
        self.CdtTrfTxInf.take().unwrap_or_else(|| CdtTrfTxInfType::new())
    }
}

impl ::protobuf::Message for FIToFICstmrCdtTrfType {
    fn is_initialized(&self) -> bool {
        for v in &self.GrpHdr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CdtTrfTxInf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.GrpHdr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CdtTrfTxInf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.GrpHdr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.CdtTrfTxInf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.GrpHdr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.CdtTrfTxInf.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FIToFICstmrCdtTrfType {
        FIToFICstmrCdtTrfType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GrpHdrType>>(
                "GrpHdr",
                |m: &FIToFICstmrCdtTrfType| { &m.GrpHdr },
                |m: &mut FIToFICstmrCdtTrfType| { &mut m.GrpHdr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CdtTrfTxInfType>>(
                "CdtTrfTxInf",
                |m: &FIToFICstmrCdtTrfType| { &m.CdtTrfTxInf },
                |m: &mut FIToFICstmrCdtTrfType| { &mut m.CdtTrfTxInf },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FIToFICstmrCdtTrfType>(
                "FIToFICstmrCdtTrfType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FIToFICstmrCdtTrfType {
        static instance: ::protobuf::rt::LazyV2<FIToFICstmrCdtTrfType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FIToFICstmrCdtTrfType::new)
    }
}

impl ::protobuf::Clear for FIToFICstmrCdtTrfType {
    fn clear(&mut self) {
        self.GrpHdr.clear();
        self.CdtTrfTxInf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FIToFICstmrCdtTrfType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FIToFICstmrCdtTrfType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CdtTrfTxInfType {
    // message fields
    pub PmtId: ::protobuf::SingularPtrField<PmtIdType>,
    pub PmtTpInf: ::protobuf::SingularPtrField<PmtTpInfType2>,
    pub IntrBkSttlmAmt: ::protobuf::SingularPtrField<CurrencyAndAmountType>,
    pub IntrBkSttlmDt: ::std::string::String,
    pub AccptncDtTm: ::std::string::String,
    pub InstdAmt: ::protobuf::SingularPtrField<CurrencyAndAmountType>,
    pub XchgRate: ::std::string::String,
    pub ChrgBr: ::std::string::String,
    pub ChrgsInf: ::protobuf::SingularPtrField<ChrgsInfType>,
    pub InstgAgt: ::protobuf::SingularPtrField<InstgAgtType>,
    pub InstdAgt: ::protobuf::SingularPtrField<InstdAgtType>,
    pub Dbtr: ::protobuf::SingularPtrField<DbtrType>,
    pub DbtrAcct: ::protobuf::SingularPtrField<DbtrAcctType>,
    pub DbtrAgt: ::protobuf::SingularPtrField<DbtrAgtType>,
    pub CdtrAgt: ::protobuf::SingularPtrField<CdtrAgtType>,
    pub Cdtr: ::protobuf::SingularPtrField<CdtrType>,
    pub CdtrAcct: ::protobuf::SingularPtrField<CdtrAcctType>,
    pub Purp: ::protobuf::SingularPtrField<PurpType>,
    pub RgltryRptg: ::protobuf::SingularPtrField<RgltryRptgType>,
    pub RmtInf: ::protobuf::SingularPtrField<RmtInfType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CdtTrfTxInfType {
    fn default() -> &'a CdtTrfTxInfType {
        <CdtTrfTxInfType as ::protobuf::Message>::default_instance()
    }
}

impl CdtTrfTxInfType {
    pub fn new() -> CdtTrfTxInfType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.PmtIdType PmtId = 1;


    pub fn get_PmtId(&self) -> &PmtIdType {
        self.PmtId.as_ref().unwrap_or_else(|| <PmtIdType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PmtId(&mut self) {
        self.PmtId.clear();
    }

    pub fn has_PmtId(&self) -> bool {
        self.PmtId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PmtId(&mut self, v: PmtIdType) {
        self.PmtId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PmtId(&mut self) -> &mut PmtIdType {
        if self.PmtId.is_none() {
            self.PmtId.set_default();
        }
        self.PmtId.as_mut().unwrap()
    }

    // Take field
    pub fn take_PmtId(&mut self) -> PmtIdType {
        self.PmtId.take().unwrap_or_else(|| PmtIdType::new())
    }

    // .protobuf.payment.PmtTpInfType2 PmtTpInf = 2;


    pub fn get_PmtTpInf(&self) -> &PmtTpInfType2 {
        self.PmtTpInf.as_ref().unwrap_or_else(|| <PmtTpInfType2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PmtTpInf(&mut self) {
        self.PmtTpInf.clear();
    }

    pub fn has_PmtTpInf(&self) -> bool {
        self.PmtTpInf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PmtTpInf(&mut self, v: PmtTpInfType2) {
        self.PmtTpInf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PmtTpInf(&mut self) -> &mut PmtTpInfType2 {
        if self.PmtTpInf.is_none() {
            self.PmtTpInf.set_default();
        }
        self.PmtTpInf.as_mut().unwrap()
    }

    // Take field
    pub fn take_PmtTpInf(&mut self) -> PmtTpInfType2 {
        self.PmtTpInf.take().unwrap_or_else(|| PmtTpInfType2::new())
    }

    // .protobuf.payment.CurrencyAndAmountType IntrBkSttlmAmt = 3;


    pub fn get_IntrBkSttlmAmt(&self) -> &CurrencyAndAmountType {
        self.IntrBkSttlmAmt.as_ref().unwrap_or_else(|| <CurrencyAndAmountType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_IntrBkSttlmAmt(&mut self) {
        self.IntrBkSttlmAmt.clear();
    }

    pub fn has_IntrBkSttlmAmt(&self) -> bool {
        self.IntrBkSttlmAmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_IntrBkSttlmAmt(&mut self, v: CurrencyAndAmountType) {
        self.IntrBkSttlmAmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_IntrBkSttlmAmt(&mut self) -> &mut CurrencyAndAmountType {
        if self.IntrBkSttlmAmt.is_none() {
            self.IntrBkSttlmAmt.set_default();
        }
        self.IntrBkSttlmAmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_IntrBkSttlmAmt(&mut self) -> CurrencyAndAmountType {
        self.IntrBkSttlmAmt.take().unwrap_or_else(|| CurrencyAndAmountType::new())
    }

    // string IntrBkSttlmDt = 4;


    pub fn get_IntrBkSttlmDt(&self) -> &str {
        &self.IntrBkSttlmDt
    }
    pub fn clear_IntrBkSttlmDt(&mut self) {
        self.IntrBkSttlmDt.clear();
    }

    // Param is passed by value, moved
    pub fn set_IntrBkSttlmDt(&mut self, v: ::std::string::String) {
        self.IntrBkSttlmDt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_IntrBkSttlmDt(&mut self) -> &mut ::std::string::String {
        &mut self.IntrBkSttlmDt
    }

    // Take field
    pub fn take_IntrBkSttlmDt(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.IntrBkSttlmDt, ::std::string::String::new())
    }

    // string AccptncDtTm = 5;


    pub fn get_AccptncDtTm(&self) -> &str {
        &self.AccptncDtTm
    }
    pub fn clear_AccptncDtTm(&mut self) {
        self.AccptncDtTm.clear();
    }

    // Param is passed by value, moved
    pub fn set_AccptncDtTm(&mut self, v: ::std::string::String) {
        self.AccptncDtTm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_AccptncDtTm(&mut self) -> &mut ::std::string::String {
        &mut self.AccptncDtTm
    }

    // Take field
    pub fn take_AccptncDtTm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.AccptncDtTm, ::std::string::String::new())
    }

    // .protobuf.payment.CurrencyAndAmountType InstdAmt = 6;


    pub fn get_InstdAmt(&self) -> &CurrencyAndAmountType {
        self.InstdAmt.as_ref().unwrap_or_else(|| <CurrencyAndAmountType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_InstdAmt(&mut self) {
        self.InstdAmt.clear();
    }

    pub fn has_InstdAmt(&self) -> bool {
        self.InstdAmt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InstdAmt(&mut self, v: CurrencyAndAmountType) {
        self.InstdAmt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_InstdAmt(&mut self) -> &mut CurrencyAndAmountType {
        if self.InstdAmt.is_none() {
            self.InstdAmt.set_default();
        }
        self.InstdAmt.as_mut().unwrap()
    }

    // Take field
    pub fn take_InstdAmt(&mut self) -> CurrencyAndAmountType {
        self.InstdAmt.take().unwrap_or_else(|| CurrencyAndAmountType::new())
    }

    // string XchgRate = 7;


    pub fn get_XchgRate(&self) -> &str {
        &self.XchgRate
    }
    pub fn clear_XchgRate(&mut self) {
        self.XchgRate.clear();
    }

    // Param is passed by value, moved
    pub fn set_XchgRate(&mut self, v: ::std::string::String) {
        self.XchgRate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_XchgRate(&mut self) -> &mut ::std::string::String {
        &mut self.XchgRate
    }

    // Take field
    pub fn take_XchgRate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.XchgRate, ::std::string::String::new())
    }

    // string ChrgBr = 8;


    pub fn get_ChrgBr(&self) -> &str {
        &self.ChrgBr
    }
    pub fn clear_ChrgBr(&mut self) {
        self.ChrgBr.clear();
    }

    // Param is passed by value, moved
    pub fn set_ChrgBr(&mut self, v: ::std::string::String) {
        self.ChrgBr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ChrgBr(&mut self) -> &mut ::std::string::String {
        &mut self.ChrgBr
    }

    // Take field
    pub fn take_ChrgBr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ChrgBr, ::std::string::String::new())
    }

    // .protobuf.payment.ChrgsInfType ChrgsInf = 9;


    pub fn get_ChrgsInf(&self) -> &ChrgsInfType {
        self.ChrgsInf.as_ref().unwrap_or_else(|| <ChrgsInfType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ChrgsInf(&mut self) {
        self.ChrgsInf.clear();
    }

    pub fn has_ChrgsInf(&self) -> bool {
        self.ChrgsInf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ChrgsInf(&mut self, v: ChrgsInfType) {
        self.ChrgsInf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ChrgsInf(&mut self) -> &mut ChrgsInfType {
        if self.ChrgsInf.is_none() {
            self.ChrgsInf.set_default();
        }
        self.ChrgsInf.as_mut().unwrap()
    }

    // Take field
    pub fn take_ChrgsInf(&mut self) -> ChrgsInfType {
        self.ChrgsInf.take().unwrap_or_else(|| ChrgsInfType::new())
    }

    // .protobuf.payment.InstgAgtType InstgAgt = 10;


    pub fn get_InstgAgt(&self) -> &InstgAgtType {
        self.InstgAgt.as_ref().unwrap_or_else(|| <InstgAgtType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_InstgAgt(&mut self) {
        self.InstgAgt.clear();
    }

    pub fn has_InstgAgt(&self) -> bool {
        self.InstgAgt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InstgAgt(&mut self, v: InstgAgtType) {
        self.InstgAgt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_InstgAgt(&mut self) -> &mut InstgAgtType {
        if self.InstgAgt.is_none() {
            self.InstgAgt.set_default();
        }
        self.InstgAgt.as_mut().unwrap()
    }

    // Take field
    pub fn take_InstgAgt(&mut self) -> InstgAgtType {
        self.InstgAgt.take().unwrap_or_else(|| InstgAgtType::new())
    }

    // .protobuf.payment.InstdAgtType InstdAgt = 11;


    pub fn get_InstdAgt(&self) -> &InstdAgtType {
        self.InstdAgt.as_ref().unwrap_or_else(|| <InstdAgtType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_InstdAgt(&mut self) {
        self.InstdAgt.clear();
    }

    pub fn has_InstdAgt(&self) -> bool {
        self.InstdAgt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InstdAgt(&mut self, v: InstdAgtType) {
        self.InstdAgt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_InstdAgt(&mut self) -> &mut InstdAgtType {
        if self.InstdAgt.is_none() {
            self.InstdAgt.set_default();
        }
        self.InstdAgt.as_mut().unwrap()
    }

    // Take field
    pub fn take_InstdAgt(&mut self) -> InstdAgtType {
        self.InstdAgt.take().unwrap_or_else(|| InstdAgtType::new())
    }

    // .protobuf.payment.DbtrType Dbtr = 12;


    pub fn get_Dbtr(&self) -> &DbtrType {
        self.Dbtr.as_ref().unwrap_or_else(|| <DbtrType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Dbtr(&mut self) {
        self.Dbtr.clear();
    }

    pub fn has_Dbtr(&self) -> bool {
        self.Dbtr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Dbtr(&mut self, v: DbtrType) {
        self.Dbtr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Dbtr(&mut self) -> &mut DbtrType {
        if self.Dbtr.is_none() {
            self.Dbtr.set_default();
        }
        self.Dbtr.as_mut().unwrap()
    }

    // Take field
    pub fn take_Dbtr(&mut self) -> DbtrType {
        self.Dbtr.take().unwrap_or_else(|| DbtrType::new())
    }

    // .protobuf.payment.DbtrAcctType DbtrAcct = 13;


    pub fn get_DbtrAcct(&self) -> &DbtrAcctType {
        self.DbtrAcct.as_ref().unwrap_or_else(|| <DbtrAcctType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DbtrAcct(&mut self) {
        self.DbtrAcct.clear();
    }

    pub fn has_DbtrAcct(&self) -> bool {
        self.DbtrAcct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DbtrAcct(&mut self, v: DbtrAcctType) {
        self.DbtrAcct = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DbtrAcct(&mut self) -> &mut DbtrAcctType {
        if self.DbtrAcct.is_none() {
            self.DbtrAcct.set_default();
        }
        self.DbtrAcct.as_mut().unwrap()
    }

    // Take field
    pub fn take_DbtrAcct(&mut self) -> DbtrAcctType {
        self.DbtrAcct.take().unwrap_or_else(|| DbtrAcctType::new())
    }

    // .protobuf.payment.DbtrAgtType DbtrAgt = 14;


    pub fn get_DbtrAgt(&self) -> &DbtrAgtType {
        self.DbtrAgt.as_ref().unwrap_or_else(|| <DbtrAgtType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_DbtrAgt(&mut self) {
        self.DbtrAgt.clear();
    }

    pub fn has_DbtrAgt(&self) -> bool {
        self.DbtrAgt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DbtrAgt(&mut self, v: DbtrAgtType) {
        self.DbtrAgt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DbtrAgt(&mut self) -> &mut DbtrAgtType {
        if self.DbtrAgt.is_none() {
            self.DbtrAgt.set_default();
        }
        self.DbtrAgt.as_mut().unwrap()
    }

    // Take field
    pub fn take_DbtrAgt(&mut self) -> DbtrAgtType {
        self.DbtrAgt.take().unwrap_or_else(|| DbtrAgtType::new())
    }

    // .protobuf.payment.CdtrAgtType CdtrAgt = 15;


    pub fn get_CdtrAgt(&self) -> &CdtrAgtType {
        self.CdtrAgt.as_ref().unwrap_or_else(|| <CdtrAgtType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_CdtrAgt(&mut self) {
        self.CdtrAgt.clear();
    }

    pub fn has_CdtrAgt(&self) -> bool {
        self.CdtrAgt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CdtrAgt(&mut self, v: CdtrAgtType) {
        self.CdtrAgt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CdtrAgt(&mut self) -> &mut CdtrAgtType {
        if self.CdtrAgt.is_none() {
            self.CdtrAgt.set_default();
        }
        self.CdtrAgt.as_mut().unwrap()
    }

    // Take field
    pub fn take_CdtrAgt(&mut self) -> CdtrAgtType {
        self.CdtrAgt.take().unwrap_or_else(|| CdtrAgtType::new())
    }

    // .protobuf.payment.CdtrType Cdtr = 16;


    pub fn get_Cdtr(&self) -> &CdtrType {
        self.Cdtr.as_ref().unwrap_or_else(|| <CdtrType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Cdtr(&mut self) {
        self.Cdtr.clear();
    }

    pub fn has_Cdtr(&self) -> bool {
        self.Cdtr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Cdtr(&mut self, v: CdtrType) {
        self.Cdtr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Cdtr(&mut self) -> &mut CdtrType {
        if self.Cdtr.is_none() {
            self.Cdtr.set_default();
        }
        self.Cdtr.as_mut().unwrap()
    }

    // Take field
    pub fn take_Cdtr(&mut self) -> CdtrType {
        self.Cdtr.take().unwrap_or_else(|| CdtrType::new())
    }

    // .protobuf.payment.CdtrAcctType CdtrAcct = 17;


    pub fn get_CdtrAcct(&self) -> &CdtrAcctType {
        self.CdtrAcct.as_ref().unwrap_or_else(|| <CdtrAcctType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_CdtrAcct(&mut self) {
        self.CdtrAcct.clear();
    }

    pub fn has_CdtrAcct(&self) -> bool {
        self.CdtrAcct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CdtrAcct(&mut self, v: CdtrAcctType) {
        self.CdtrAcct = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CdtrAcct(&mut self) -> &mut CdtrAcctType {
        if self.CdtrAcct.is_none() {
            self.CdtrAcct.set_default();
        }
        self.CdtrAcct.as_mut().unwrap()
    }

    // Take field
    pub fn take_CdtrAcct(&mut self) -> CdtrAcctType {
        self.CdtrAcct.take().unwrap_or_else(|| CdtrAcctType::new())
    }

    // .protobuf.payment.PurpType Purp = 18;


    pub fn get_Purp(&self) -> &PurpType {
        self.Purp.as_ref().unwrap_or_else(|| <PurpType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Purp(&mut self) {
        self.Purp.clear();
    }

    pub fn has_Purp(&self) -> bool {
        self.Purp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Purp(&mut self, v: PurpType) {
        self.Purp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Purp(&mut self) -> &mut PurpType {
        if self.Purp.is_none() {
            self.Purp.set_default();
        }
        self.Purp.as_mut().unwrap()
    }

    // Take field
    pub fn take_Purp(&mut self) -> PurpType {
        self.Purp.take().unwrap_or_else(|| PurpType::new())
    }

    // .protobuf.payment.RgltryRptgType RgltryRptg = 19;


    pub fn get_RgltryRptg(&self) -> &RgltryRptgType {
        self.RgltryRptg.as_ref().unwrap_or_else(|| <RgltryRptgType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_RgltryRptg(&mut self) {
        self.RgltryRptg.clear();
    }

    pub fn has_RgltryRptg(&self) -> bool {
        self.RgltryRptg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RgltryRptg(&mut self, v: RgltryRptgType) {
        self.RgltryRptg = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_RgltryRptg(&mut self) -> &mut RgltryRptgType {
        if self.RgltryRptg.is_none() {
            self.RgltryRptg.set_default();
        }
        self.RgltryRptg.as_mut().unwrap()
    }

    // Take field
    pub fn take_RgltryRptg(&mut self) -> RgltryRptgType {
        self.RgltryRptg.take().unwrap_or_else(|| RgltryRptgType::new())
    }

    // .protobuf.payment.RmtInfType RmtInf = 20;


    pub fn get_RmtInf(&self) -> &RmtInfType {
        self.RmtInf.as_ref().unwrap_or_else(|| <RmtInfType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_RmtInf(&mut self) {
        self.RmtInf.clear();
    }

    pub fn has_RmtInf(&self) -> bool {
        self.RmtInf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_RmtInf(&mut self, v: RmtInfType) {
        self.RmtInf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_RmtInf(&mut self) -> &mut RmtInfType {
        if self.RmtInf.is_none() {
            self.RmtInf.set_default();
        }
        self.RmtInf.as_mut().unwrap()
    }

    // Take field
    pub fn take_RmtInf(&mut self) -> RmtInfType {
        self.RmtInf.take().unwrap_or_else(|| RmtInfType::new())
    }
}

impl ::protobuf::Message for CdtTrfTxInfType {
    fn is_initialized(&self) -> bool {
        for v in &self.PmtId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PmtTpInf {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.IntrBkSttlmAmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.InstdAmt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ChrgsInf {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.InstgAgt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.InstdAgt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Dbtr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DbtrAcct {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DbtrAgt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CdtrAgt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Cdtr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CdtrAcct {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Purp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.RgltryRptg {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.RmtInf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PmtId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PmtTpInf)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.IntrBkSttlmAmt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.IntrBkSttlmDt)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.AccptncDtTm)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.InstdAmt)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.XchgRate)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ChrgBr)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ChrgsInf)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.InstgAgt)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.InstdAgt)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Dbtr)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DbtrAcct)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DbtrAgt)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CdtrAgt)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Cdtr)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CdtrAcct)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Purp)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.RgltryRptg)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.RmtInf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.PmtId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PmtTpInf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.IntrBkSttlmAmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.IntrBkSttlmDt.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.IntrBkSttlmDt);
        }
        if !self.AccptncDtTm.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.AccptncDtTm);
        }
        if let Some(ref v) = self.InstdAmt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.XchgRate.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.XchgRate);
        }
        if !self.ChrgBr.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.ChrgBr);
        }
        if let Some(ref v) = self.ChrgsInf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.InstgAgt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.InstdAgt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Dbtr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DbtrAcct.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DbtrAgt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.CdtrAgt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Cdtr.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.CdtrAcct.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Purp.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.RgltryRptg.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.RmtInf.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.PmtId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PmtTpInf.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.IntrBkSttlmAmt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.IntrBkSttlmDt.is_empty() {
            os.write_string(4, &self.IntrBkSttlmDt)?;
        }
        if !self.AccptncDtTm.is_empty() {
            os.write_string(5, &self.AccptncDtTm)?;
        }
        if let Some(ref v) = self.InstdAmt.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.XchgRate.is_empty() {
            os.write_string(7, &self.XchgRate)?;
        }
        if !self.ChrgBr.is_empty() {
            os.write_string(8, &self.ChrgBr)?;
        }
        if let Some(ref v) = self.ChrgsInf.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.InstgAgt.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.InstdAgt.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Dbtr.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DbtrAcct.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DbtrAgt.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.CdtrAgt.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Cdtr.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.CdtrAcct.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Purp.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.RgltryRptg.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.RmtInf.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CdtTrfTxInfType {
        CdtTrfTxInfType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PmtIdType>>(
                "PmtId",
                |m: &CdtTrfTxInfType| { &m.PmtId },
                |m: &mut CdtTrfTxInfType| { &mut m.PmtId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PmtTpInfType2>>(
                "PmtTpInf",
                |m: &CdtTrfTxInfType| { &m.PmtTpInf },
                |m: &mut CdtTrfTxInfType| { &mut m.PmtTpInf },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CurrencyAndAmountType>>(
                "IntrBkSttlmAmt",
                |m: &CdtTrfTxInfType| { &m.IntrBkSttlmAmt },
                |m: &mut CdtTrfTxInfType| { &mut m.IntrBkSttlmAmt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "IntrBkSttlmDt",
                |m: &CdtTrfTxInfType| { &m.IntrBkSttlmDt },
                |m: &mut CdtTrfTxInfType| { &mut m.IntrBkSttlmDt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "AccptncDtTm",
                |m: &CdtTrfTxInfType| { &m.AccptncDtTm },
                |m: &mut CdtTrfTxInfType| { &mut m.AccptncDtTm },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CurrencyAndAmountType>>(
                "InstdAmt",
                |m: &CdtTrfTxInfType| { &m.InstdAmt },
                |m: &mut CdtTrfTxInfType| { &mut m.InstdAmt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "XchgRate",
                |m: &CdtTrfTxInfType| { &m.XchgRate },
                |m: &mut CdtTrfTxInfType| { &mut m.XchgRate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ChrgBr",
                |m: &CdtTrfTxInfType| { &m.ChrgBr },
                |m: &mut CdtTrfTxInfType| { &mut m.ChrgBr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ChrgsInfType>>(
                "ChrgsInf",
                |m: &CdtTrfTxInfType| { &m.ChrgsInf },
                |m: &mut CdtTrfTxInfType| { &mut m.ChrgsInf },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstgAgtType>>(
                "InstgAgt",
                |m: &CdtTrfTxInfType| { &m.InstgAgt },
                |m: &mut CdtTrfTxInfType| { &mut m.InstgAgt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstdAgtType>>(
                "InstdAgt",
                |m: &CdtTrfTxInfType| { &m.InstdAgt },
                |m: &mut CdtTrfTxInfType| { &mut m.InstdAgt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DbtrType>>(
                "Dbtr",
                |m: &CdtTrfTxInfType| { &m.Dbtr },
                |m: &mut CdtTrfTxInfType| { &mut m.Dbtr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DbtrAcctType>>(
                "DbtrAcct",
                |m: &CdtTrfTxInfType| { &m.DbtrAcct },
                |m: &mut CdtTrfTxInfType| { &mut m.DbtrAcct },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DbtrAgtType>>(
                "DbtrAgt",
                |m: &CdtTrfTxInfType| { &m.DbtrAgt },
                |m: &mut CdtTrfTxInfType| { &mut m.DbtrAgt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CdtrAgtType>>(
                "CdtrAgt",
                |m: &CdtTrfTxInfType| { &m.CdtrAgt },
                |m: &mut CdtTrfTxInfType| { &mut m.CdtrAgt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CdtrType>>(
                "Cdtr",
                |m: &CdtTrfTxInfType| { &m.Cdtr },
                |m: &mut CdtTrfTxInfType| { &mut m.Cdtr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CdtrAcctType>>(
                "CdtrAcct",
                |m: &CdtTrfTxInfType| { &m.CdtrAcct },
                |m: &mut CdtTrfTxInfType| { &mut m.CdtrAcct },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PurpType>>(
                "Purp",
                |m: &CdtTrfTxInfType| { &m.Purp },
                |m: &mut CdtTrfTxInfType| { &mut m.Purp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RgltryRptgType>>(
                "RgltryRptg",
                |m: &CdtTrfTxInfType| { &m.RgltryRptg },
                |m: &mut CdtTrfTxInfType| { &mut m.RgltryRptg },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RmtInfType>>(
                "RmtInf",
                |m: &CdtTrfTxInfType| { &m.RmtInf },
                |m: &mut CdtTrfTxInfType| { &mut m.RmtInf },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CdtTrfTxInfType>(
                "CdtTrfTxInfType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CdtTrfTxInfType {
        static instance: ::protobuf::rt::LazyV2<CdtTrfTxInfType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CdtTrfTxInfType::new)
    }
}

impl ::protobuf::Clear for CdtTrfTxInfType {
    fn clear(&mut self) {
        self.PmtId.clear();
        self.PmtTpInf.clear();
        self.IntrBkSttlmAmt.clear();
        self.IntrBkSttlmDt.clear();
        self.AccptncDtTm.clear();
        self.InstdAmt.clear();
        self.XchgRate.clear();
        self.ChrgBr.clear();
        self.ChrgsInf.clear();
        self.InstgAgt.clear();
        self.InstdAgt.clear();
        self.Dbtr.clear();
        self.DbtrAcct.clear();
        self.DbtrAgt.clear();
        self.CdtrAgt.clear();
        self.Cdtr.clear();
        self.CdtrAcct.clear();
        self.Purp.clear();
        self.RgltryRptg.clear();
        self.RmtInf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CdtTrfTxInfType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CdtTrfTxInfType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RmtInfType {
    // message fields
    pub Ustrd: ::std::string::String,
    pub Strd: ::protobuf::SingularPtrField<StrdType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RmtInfType {
    fn default() -> &'a RmtInfType {
        <RmtInfType as ::protobuf::Message>::default_instance()
    }
}

impl RmtInfType {
    pub fn new() -> RmtInfType {
        ::std::default::Default::default()
    }

    // string Ustrd = 1;


    pub fn get_Ustrd(&self) -> &str {
        &self.Ustrd
    }
    pub fn clear_Ustrd(&mut self) {
        self.Ustrd.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ustrd(&mut self, v: ::std::string::String) {
        self.Ustrd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Ustrd(&mut self) -> &mut ::std::string::String {
        &mut self.Ustrd
    }

    // Take field
    pub fn take_Ustrd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Ustrd, ::std::string::String::new())
    }

    // .protobuf.payment.StrdType Strd = 2;


    pub fn get_Strd(&self) -> &StrdType {
        self.Strd.as_ref().unwrap_or_else(|| <StrdType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Strd(&mut self) {
        self.Strd.clear();
    }

    pub fn has_Strd(&self) -> bool {
        self.Strd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Strd(&mut self, v: StrdType) {
        self.Strd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Strd(&mut self) -> &mut StrdType {
        if self.Strd.is_none() {
            self.Strd.set_default();
        }
        self.Strd.as_mut().unwrap()
    }

    // Take field
    pub fn take_Strd(&mut self) -> StrdType {
        self.Strd.take().unwrap_or_else(|| StrdType::new())
    }
}

impl ::protobuf::Message for RmtInfType {
    fn is_initialized(&self) -> bool {
        for v in &self.Strd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Ustrd)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Strd)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Ustrd.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Ustrd);
        }
        if let Some(ref v) = self.Strd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Ustrd.is_empty() {
            os.write_string(1, &self.Ustrd)?;
        }
        if let Some(ref v) = self.Strd.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RmtInfType {
        RmtInfType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Ustrd",
                |m: &RmtInfType| { &m.Ustrd },
                |m: &mut RmtInfType| { &mut m.Ustrd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StrdType>>(
                "Strd",
                |m: &RmtInfType| { &m.Strd },
                |m: &mut RmtInfType| { &mut m.Strd },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RmtInfType>(
                "RmtInfType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RmtInfType {
        static instance: ::protobuf::rt::LazyV2<RmtInfType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RmtInfType::new)
    }
}

impl ::protobuf::Clear for RmtInfType {
    fn clear(&mut self) {
        self.Ustrd.clear();
        self.Strd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RmtInfType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RmtInfType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StrdType {
    // message fields
    pub CdtrRefInf: ::protobuf::SingularPtrField<CdtrRefInfType>,
    pub AddtlRmtInf: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StrdType {
    fn default() -> &'a StrdType {
        <StrdType as ::protobuf::Message>::default_instance()
    }
}

impl StrdType {
    pub fn new() -> StrdType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.CdtrRefInfType CdtrRefInf = 1;


    pub fn get_CdtrRefInf(&self) -> &CdtrRefInfType {
        self.CdtrRefInf.as_ref().unwrap_or_else(|| <CdtrRefInfType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_CdtrRefInf(&mut self) {
        self.CdtrRefInf.clear();
    }

    pub fn has_CdtrRefInf(&self) -> bool {
        self.CdtrRefInf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CdtrRefInf(&mut self, v: CdtrRefInfType) {
        self.CdtrRefInf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CdtrRefInf(&mut self) -> &mut CdtrRefInfType {
        if self.CdtrRefInf.is_none() {
            self.CdtrRefInf.set_default();
        }
        self.CdtrRefInf.as_mut().unwrap()
    }

    // Take field
    pub fn take_CdtrRefInf(&mut self) -> CdtrRefInfType {
        self.CdtrRefInf.take().unwrap_or_else(|| CdtrRefInfType::new())
    }

    // repeated string AddtlRmtInf = 2;


    pub fn get_AddtlRmtInf(&self) -> &[::std::string::String] {
        &self.AddtlRmtInf
    }
    pub fn clear_AddtlRmtInf(&mut self) {
        self.AddtlRmtInf.clear();
    }

    // Param is passed by value, moved
    pub fn set_AddtlRmtInf(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.AddtlRmtInf = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AddtlRmtInf(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.AddtlRmtInf
    }

    // Take field
    pub fn take_AddtlRmtInf(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.AddtlRmtInf, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for StrdType {
    fn is_initialized(&self) -> bool {
        for v in &self.CdtrRefInf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CdtrRefInf)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.AddtlRmtInf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.CdtrRefInf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.AddtlRmtInf {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.CdtrRefInf.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.AddtlRmtInf {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StrdType {
        StrdType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CdtrRefInfType>>(
                "CdtrRefInf",
                |m: &StrdType| { &m.CdtrRefInf },
                |m: &mut StrdType| { &mut m.CdtrRefInf },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "AddtlRmtInf",
                |m: &StrdType| { &m.AddtlRmtInf },
                |m: &mut StrdType| { &mut m.AddtlRmtInf },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StrdType>(
                "StrdType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StrdType {
        static instance: ::protobuf::rt::LazyV2<StrdType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StrdType::new)
    }
}

impl ::protobuf::Clear for StrdType {
    fn clear(&mut self) {
        self.CdtrRefInf.clear();
        self.AddtlRmtInf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StrdType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StrdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CdtrRefInfType {
    // message fields
    pub Ref: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CdtrRefInfType {
    fn default() -> &'a CdtrRefInfType {
        <CdtrRefInfType as ::protobuf::Message>::default_instance()
    }
}

impl CdtrRefInfType {
    pub fn new() -> CdtrRefInfType {
        ::std::default::Default::default()
    }

    // string Ref = 1;


    pub fn get_Ref(&self) -> &str {
        &self.Ref
    }
    pub fn clear_Ref(&mut self) {
        self.Ref.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ref(&mut self, v: ::std::string::String) {
        self.Ref = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Ref(&mut self) -> &mut ::std::string::String {
        &mut self.Ref
    }

    // Take field
    pub fn take_Ref(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Ref, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CdtrRefInfType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Ref)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Ref.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Ref);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Ref.is_empty() {
            os.write_string(1, &self.Ref)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CdtrRefInfType {
        CdtrRefInfType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Ref",
                |m: &CdtrRefInfType| { &m.Ref },
                |m: &mut CdtrRefInfType| { &mut m.Ref },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CdtrRefInfType>(
                "CdtrRefInfType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CdtrRefInfType {
        static instance: ::protobuf::rt::LazyV2<CdtrRefInfType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CdtrRefInfType::new)
    }
}

impl ::protobuf::Clear for CdtrRefInfType {
    fn clear(&mut self) {
        self.Ref.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CdtrRefInfType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CdtrRefInfType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RgltryRptgType {
    // message fields
    pub Dtls: ::protobuf::SingularPtrField<DtlsType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RgltryRptgType {
    fn default() -> &'a RgltryRptgType {
        <RgltryRptgType as ::protobuf::Message>::default_instance()
    }
}

impl RgltryRptgType {
    pub fn new() -> RgltryRptgType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.DtlsType Dtls = 1;


    pub fn get_Dtls(&self) -> &DtlsType {
        self.Dtls.as_ref().unwrap_or_else(|| <DtlsType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Dtls(&mut self) {
        self.Dtls.clear();
    }

    pub fn has_Dtls(&self) -> bool {
        self.Dtls.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Dtls(&mut self, v: DtlsType) {
        self.Dtls = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Dtls(&mut self) -> &mut DtlsType {
        if self.Dtls.is_none() {
            self.Dtls.set_default();
        }
        self.Dtls.as_mut().unwrap()
    }

    // Take field
    pub fn take_Dtls(&mut self) -> DtlsType {
        self.Dtls.take().unwrap_or_else(|| DtlsType::new())
    }
}

impl ::protobuf::Message for RgltryRptgType {
    fn is_initialized(&self) -> bool {
        for v in &self.Dtls {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Dtls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Dtls.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Dtls.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RgltryRptgType {
        RgltryRptgType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DtlsType>>(
                "Dtls",
                |m: &RgltryRptgType| { &m.Dtls },
                |m: &mut RgltryRptgType| { &mut m.Dtls },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RgltryRptgType>(
                "RgltryRptgType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RgltryRptgType {
        static instance: ::protobuf::rt::LazyV2<RgltryRptgType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RgltryRptgType::new)
    }
}

impl ::protobuf::Clear for RgltryRptgType {
    fn clear(&mut self) {
        self.Dtls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RgltryRptgType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RgltryRptgType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DtlsType {
    // message fields
    pub Inf: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DtlsType {
    fn default() -> &'a DtlsType {
        <DtlsType as ::protobuf::Message>::default_instance()
    }
}

impl DtlsType {
    pub fn new() -> DtlsType {
        ::std::default::Default::default()
    }

    // repeated string Inf = 1;


    pub fn get_Inf(&self) -> &[::std::string::String] {
        &self.Inf
    }
    pub fn clear_Inf(&mut self) {
        self.Inf.clear();
    }

    // Param is passed by value, moved
    pub fn set_Inf(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.Inf = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Inf(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.Inf
    }

    // Take field
    pub fn take_Inf(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.Inf, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DtlsType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.Inf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.Inf {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.Inf {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DtlsType {
        DtlsType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Inf",
                |m: &DtlsType| { &m.Inf },
                |m: &mut DtlsType| { &mut m.Inf },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DtlsType>(
                "DtlsType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DtlsType {
        static instance: ::protobuf::rt::LazyV2<DtlsType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DtlsType::new)
    }
}

impl ::protobuf::Clear for DtlsType {
    fn clear(&mut self) {
        self.Inf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DtlsType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DtlsType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PurpType {
    // message fields
    pub Cd: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PurpType {
    fn default() -> &'a PurpType {
        <PurpType as ::protobuf::Message>::default_instance()
    }
}

impl PurpType {
    pub fn new() -> PurpType {
        ::std::default::Default::default()
    }

    // string Cd = 1;


    pub fn get_Cd(&self) -> &str {
        &self.Cd
    }
    pub fn clear_Cd(&mut self) {
        self.Cd.clear();
    }

    // Param is passed by value, moved
    pub fn set_Cd(&mut self, v: ::std::string::String) {
        self.Cd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Cd(&mut self) -> &mut ::std::string::String {
        &mut self.Cd
    }

    // Take field
    pub fn take_Cd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Cd, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PurpType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Cd)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Cd.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Cd);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Cd.is_empty() {
            os.write_string(1, &self.Cd)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PurpType {
        PurpType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Cd",
                |m: &PurpType| { &m.Cd },
                |m: &mut PurpType| { &mut m.Cd },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PurpType>(
                "PurpType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PurpType {
        static instance: ::protobuf::rt::LazyV2<PurpType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PurpType::new)
    }
}

impl ::protobuf::Clear for PurpType {
    fn clear(&mut self) {
        self.Cd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PurpType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PurpType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CdtrAcctType {
    // message fields
    pub Id: ::protobuf::SingularPtrField<IdType2>,
    pub Tp: ::protobuf::SingularPtrField<TpType>,
    pub Nm: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CdtrAcctType {
    fn default() -> &'a CdtrAcctType {
        <CdtrAcctType as ::protobuf::Message>::default_instance()
    }
}

impl CdtrAcctType {
    pub fn new() -> CdtrAcctType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.IdType2 Id = 1;


    pub fn get_Id(&self) -> &IdType2 {
        self.Id.as_ref().unwrap_or_else(|| <IdType2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Id(&mut self) {
        self.Id.clear();
    }

    pub fn has_Id(&self) -> bool {
        self.Id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: IdType2) {
        self.Id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Id(&mut self) -> &mut IdType2 {
        if self.Id.is_none() {
            self.Id.set_default();
        }
        self.Id.as_mut().unwrap()
    }

    // Take field
    pub fn take_Id(&mut self) -> IdType2 {
        self.Id.take().unwrap_or_else(|| IdType2::new())
    }

    // .protobuf.payment.TpType Tp = 2;


    pub fn get_Tp(&self) -> &TpType {
        self.Tp.as_ref().unwrap_or_else(|| <TpType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Tp(&mut self) {
        self.Tp.clear();
    }

    pub fn has_Tp(&self) -> bool {
        self.Tp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Tp(&mut self, v: TpType) {
        self.Tp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Tp(&mut self) -> &mut TpType {
        if self.Tp.is_none() {
            self.Tp.set_default();
        }
        self.Tp.as_mut().unwrap()
    }

    // Take field
    pub fn take_Tp(&mut self) -> TpType {
        self.Tp.take().unwrap_or_else(|| TpType::new())
    }

    // string Nm = 3;


    pub fn get_Nm(&self) -> &str {
        &self.Nm
    }
    pub fn clear_Nm(&mut self) {
        self.Nm.clear();
    }

    // Param is passed by value, moved
    pub fn set_Nm(&mut self, v: ::std::string::String) {
        self.Nm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Nm(&mut self) -> &mut ::std::string::String {
        &mut self.Nm
    }

    // Take field
    pub fn take_Nm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Nm, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CdtrAcctType {
    fn is_initialized(&self) -> bool {
        for v in &self.Id {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Tp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Tp)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Nm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Tp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.Nm.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.Nm);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Tp.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.Nm.is_empty() {
            os.write_string(3, &self.Nm)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CdtrAcctType {
        CdtrAcctType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdType2>>(
                "Id",
                |m: &CdtrAcctType| { &m.Id },
                |m: &mut CdtrAcctType| { &mut m.Id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TpType>>(
                "Tp",
                |m: &CdtrAcctType| { &m.Tp },
                |m: &mut CdtrAcctType| { &mut m.Tp },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Nm",
                |m: &CdtrAcctType| { &m.Nm },
                |m: &mut CdtrAcctType| { &mut m.Nm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CdtrAcctType>(
                "CdtrAcctType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CdtrAcctType {
        static instance: ::protobuf::rt::LazyV2<CdtrAcctType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CdtrAcctType::new)
    }
}

impl ::protobuf::Clear for CdtrAcctType {
    fn clear(&mut self) {
        self.Id.clear();
        self.Tp.clear();
        self.Nm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CdtrAcctType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CdtrAcctType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TpType {
    // message fields
    pub Prtry: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TpType {
    fn default() -> &'a TpType {
        <TpType as ::protobuf::Message>::default_instance()
    }
}

impl TpType {
    pub fn new() -> TpType {
        ::std::default::Default::default()
    }

    // string Prtry = 1;


    pub fn get_Prtry(&self) -> &str {
        &self.Prtry
    }
    pub fn clear_Prtry(&mut self) {
        self.Prtry.clear();
    }

    // Param is passed by value, moved
    pub fn set_Prtry(&mut self, v: ::std::string::String) {
        self.Prtry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Prtry(&mut self) -> &mut ::std::string::String {
        &mut self.Prtry
    }

    // Take field
    pub fn take_Prtry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Prtry, ::std::string::String::new())
    }
}

impl ::protobuf::Message for TpType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Prtry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Prtry.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Prtry);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Prtry.is_empty() {
            os.write_string(1, &self.Prtry)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TpType {
        TpType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Prtry",
                |m: &TpType| { &m.Prtry },
                |m: &mut TpType| { &mut m.Prtry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TpType>(
                "TpType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TpType {
        static instance: ::protobuf::rt::LazyV2<TpType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TpType::new)
    }
}

impl ::protobuf::Clear for TpType {
    fn clear(&mut self) {
        self.Prtry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TpType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TpType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IdType2 {
    // message fields
    pub Othr: ::protobuf::SingularPtrField<OthrType2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdType2 {
    fn default() -> &'a IdType2 {
        <IdType2 as ::protobuf::Message>::default_instance()
    }
}

impl IdType2 {
    pub fn new() -> IdType2 {
        ::std::default::Default::default()
    }

    // .protobuf.payment.OthrType2 Othr = 1;


    pub fn get_Othr(&self) -> &OthrType2 {
        self.Othr.as_ref().unwrap_or_else(|| <OthrType2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Othr(&mut self) {
        self.Othr.clear();
    }

    pub fn has_Othr(&self) -> bool {
        self.Othr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Othr(&mut self, v: OthrType2) {
        self.Othr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Othr(&mut self) -> &mut OthrType2 {
        if self.Othr.is_none() {
            self.Othr.set_default();
        }
        self.Othr.as_mut().unwrap()
    }

    // Take field
    pub fn take_Othr(&mut self) -> OthrType2 {
        self.Othr.take().unwrap_or_else(|| OthrType2::new())
    }
}

impl ::protobuf::Message for IdType2 {
    fn is_initialized(&self) -> bool {
        for v in &self.Othr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Othr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Othr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Othr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdType2 {
        IdType2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OthrType2>>(
                "Othr",
                |m: &IdType2| { &m.Othr },
                |m: &mut IdType2| { &mut m.Othr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IdType2>(
                "IdType2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IdType2 {
        static instance: ::protobuf::rt::LazyV2<IdType2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IdType2::new)
    }
}

impl ::protobuf::Clear for IdType2 {
    fn clear(&mut self) {
        self.Othr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdType2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdType2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CdtrType {
    // message fields
    pub PstlAdr: ::protobuf::SingularPtrField<PstlAdrType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CdtrType {
    fn default() -> &'a CdtrType {
        <CdtrType as ::protobuf::Message>::default_instance()
    }
}

impl CdtrType {
    pub fn new() -> CdtrType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.PstlAdrType PstlAdr = 1;


    pub fn get_PstlAdr(&self) -> &PstlAdrType {
        self.PstlAdr.as_ref().unwrap_or_else(|| <PstlAdrType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PstlAdr(&mut self) {
        self.PstlAdr.clear();
    }

    pub fn has_PstlAdr(&self) -> bool {
        self.PstlAdr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PstlAdr(&mut self, v: PstlAdrType) {
        self.PstlAdr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PstlAdr(&mut self) -> &mut PstlAdrType {
        if self.PstlAdr.is_none() {
            self.PstlAdr.set_default();
        }
        self.PstlAdr.as_mut().unwrap()
    }

    // Take field
    pub fn take_PstlAdr(&mut self) -> PstlAdrType {
        self.PstlAdr.take().unwrap_or_else(|| PstlAdrType::new())
    }
}

impl ::protobuf::Message for CdtrType {
    fn is_initialized(&self) -> bool {
        for v in &self.PstlAdr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PstlAdr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.PstlAdr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.PstlAdr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CdtrType {
        CdtrType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PstlAdrType>>(
                "PstlAdr",
                |m: &CdtrType| { &m.PstlAdr },
                |m: &mut CdtrType| { &mut m.PstlAdr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CdtrType>(
                "CdtrType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CdtrType {
        static instance: ::protobuf::rt::LazyV2<CdtrType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CdtrType::new)
    }
}

impl ::protobuf::Clear for CdtrType {
    fn clear(&mut self) {
        self.PstlAdr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CdtrType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CdtrType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CdtrAgtType {
    // message fields
    pub FinInstnId: ::protobuf::SingularPtrField<FinInstnIdType5>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CdtrAgtType {
    fn default() -> &'a CdtrAgtType {
        <CdtrAgtType as ::protobuf::Message>::default_instance()
    }
}

impl CdtrAgtType {
    pub fn new() -> CdtrAgtType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.FinInstnIdType5 FinInstnId = 1;


    pub fn get_FinInstnId(&self) -> &FinInstnIdType5 {
        self.FinInstnId.as_ref().unwrap_or_else(|| <FinInstnIdType5 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_FinInstnId(&mut self) {
        self.FinInstnId.clear();
    }

    pub fn has_FinInstnId(&self) -> bool {
        self.FinInstnId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FinInstnId(&mut self, v: FinInstnIdType5) {
        self.FinInstnId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FinInstnId(&mut self) -> &mut FinInstnIdType5 {
        if self.FinInstnId.is_none() {
            self.FinInstnId.set_default();
        }
        self.FinInstnId.as_mut().unwrap()
    }

    // Take field
    pub fn take_FinInstnId(&mut self) -> FinInstnIdType5 {
        self.FinInstnId.take().unwrap_or_else(|| FinInstnIdType5::new())
    }
}

impl ::protobuf::Message for CdtrAgtType {
    fn is_initialized(&self) -> bool {
        for v in &self.FinInstnId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.FinInstnId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.FinInstnId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.FinInstnId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CdtrAgtType {
        CdtrAgtType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FinInstnIdType5>>(
                "FinInstnId",
                |m: &CdtrAgtType| { &m.FinInstnId },
                |m: &mut CdtrAgtType| { &mut m.FinInstnId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CdtrAgtType>(
                "CdtrAgtType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CdtrAgtType {
        static instance: ::protobuf::rt::LazyV2<CdtrAgtType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CdtrAgtType::new)
    }
}

impl ::protobuf::Clear for CdtrAgtType {
    fn clear(&mut self) {
        self.FinInstnId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CdtrAgtType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CdtrAgtType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DbtrAgtType {
    // message fields
    pub FinInstnId: ::protobuf::SingularPtrField<FinInstnIdType2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DbtrAgtType {
    fn default() -> &'a DbtrAgtType {
        <DbtrAgtType as ::protobuf::Message>::default_instance()
    }
}

impl DbtrAgtType {
    pub fn new() -> DbtrAgtType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.FinInstnIdType2 FinInstnId = 1;


    pub fn get_FinInstnId(&self) -> &FinInstnIdType2 {
        self.FinInstnId.as_ref().unwrap_or_else(|| <FinInstnIdType2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_FinInstnId(&mut self) {
        self.FinInstnId.clear();
    }

    pub fn has_FinInstnId(&self) -> bool {
        self.FinInstnId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FinInstnId(&mut self, v: FinInstnIdType2) {
        self.FinInstnId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FinInstnId(&mut self) -> &mut FinInstnIdType2 {
        if self.FinInstnId.is_none() {
            self.FinInstnId.set_default();
        }
        self.FinInstnId.as_mut().unwrap()
    }

    // Take field
    pub fn take_FinInstnId(&mut self) -> FinInstnIdType2 {
        self.FinInstnId.take().unwrap_or_else(|| FinInstnIdType2::new())
    }
}

impl ::protobuf::Message for DbtrAgtType {
    fn is_initialized(&self) -> bool {
        for v in &self.FinInstnId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.FinInstnId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.FinInstnId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.FinInstnId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DbtrAgtType {
        DbtrAgtType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FinInstnIdType2>>(
                "FinInstnId",
                |m: &DbtrAgtType| { &m.FinInstnId },
                |m: &mut DbtrAgtType| { &mut m.FinInstnId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DbtrAgtType>(
                "DbtrAgtType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DbtrAgtType {
        static instance: ::protobuf::rt::LazyV2<DbtrAgtType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DbtrAgtType::new)
    }
}

impl ::protobuf::Clear for DbtrAgtType {
    fn clear(&mut self) {
        self.FinInstnId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DbtrAgtType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DbtrAgtType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DbtrAcctType {
    // message fields
    pub Id: ::protobuf::SingularPtrField<IdType>,
    pub Nm: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DbtrAcctType {
    fn default() -> &'a DbtrAcctType {
        <DbtrAcctType as ::protobuf::Message>::default_instance()
    }
}

impl DbtrAcctType {
    pub fn new() -> DbtrAcctType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.IdType Id = 1;


    pub fn get_Id(&self) -> &IdType {
        self.Id.as_ref().unwrap_or_else(|| <IdType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Id(&mut self) {
        self.Id.clear();
    }

    pub fn has_Id(&self) -> bool {
        self.Id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: IdType) {
        self.Id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Id(&mut self) -> &mut IdType {
        if self.Id.is_none() {
            self.Id.set_default();
        }
        self.Id.as_mut().unwrap()
    }

    // Take field
    pub fn take_Id(&mut self) -> IdType {
        self.Id.take().unwrap_or_else(|| IdType::new())
    }

    // string Nm = 2;


    pub fn get_Nm(&self) -> &str {
        &self.Nm
    }
    pub fn clear_Nm(&mut self) {
        self.Nm.clear();
    }

    // Param is passed by value, moved
    pub fn set_Nm(&mut self, v: ::std::string::String) {
        self.Nm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Nm(&mut self) -> &mut ::std::string::String {
        &mut self.Nm
    }

    // Take field
    pub fn take_Nm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Nm, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DbtrAcctType {
    fn is_initialized(&self) -> bool {
        for v in &self.Id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Nm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.Nm.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Nm);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Id.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.Nm.is_empty() {
            os.write_string(2, &self.Nm)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DbtrAcctType {
        DbtrAcctType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdType>>(
                "Id",
                |m: &DbtrAcctType| { &m.Id },
                |m: &mut DbtrAcctType| { &mut m.Id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Nm",
                |m: &DbtrAcctType| { &m.Nm },
                |m: &mut DbtrAcctType| { &mut m.Nm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DbtrAcctType>(
                "DbtrAcctType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DbtrAcctType {
        static instance: ::protobuf::rt::LazyV2<DbtrAcctType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DbtrAcctType::new)
    }
}

impl ::protobuf::Clear for DbtrAcctType {
    fn clear(&mut self) {
        self.Id.clear();
        self.Nm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DbtrAcctType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DbtrAcctType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IdType {
    // message fields
    pub IBAN: ::std::string::String,
    pub Othr: ::protobuf::SingularPtrField<OthrType2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdType {
    fn default() -> &'a IdType {
        <IdType as ::protobuf::Message>::default_instance()
    }
}

impl IdType {
    pub fn new() -> IdType {
        ::std::default::Default::default()
    }

    // string IBAN = 1;


    pub fn get_IBAN(&self) -> &str {
        &self.IBAN
    }
    pub fn clear_IBAN(&mut self) {
        self.IBAN.clear();
    }

    // Param is passed by value, moved
    pub fn set_IBAN(&mut self, v: ::std::string::String) {
        self.IBAN = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_IBAN(&mut self) -> &mut ::std::string::String {
        &mut self.IBAN
    }

    // Take field
    pub fn take_IBAN(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.IBAN, ::std::string::String::new())
    }

    // .protobuf.payment.OthrType2 Othr = 2;


    pub fn get_Othr(&self) -> &OthrType2 {
        self.Othr.as_ref().unwrap_or_else(|| <OthrType2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Othr(&mut self) {
        self.Othr.clear();
    }

    pub fn has_Othr(&self) -> bool {
        self.Othr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Othr(&mut self, v: OthrType2) {
        self.Othr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Othr(&mut self) -> &mut OthrType2 {
        if self.Othr.is_none() {
            self.Othr.set_default();
        }
        self.Othr.as_mut().unwrap()
    }

    // Take field
    pub fn take_Othr(&mut self) -> OthrType2 {
        self.Othr.take().unwrap_or_else(|| OthrType2::new())
    }
}

impl ::protobuf::Message for IdType {
    fn is_initialized(&self) -> bool {
        for v in &self.Othr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.IBAN)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Othr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.IBAN.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.IBAN);
        }
        if let Some(ref v) = self.Othr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.IBAN.is_empty() {
            os.write_string(1, &self.IBAN)?;
        }
        if let Some(ref v) = self.Othr.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdType {
        IdType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "IBAN",
                |m: &IdType| { &m.IBAN },
                |m: &mut IdType| { &mut m.IBAN },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OthrType2>>(
                "Othr",
                |m: &IdType| { &m.Othr },
                |m: &mut IdType| { &mut m.Othr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IdType>(
                "IdType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IdType {
        static instance: ::protobuf::rt::LazyV2<IdType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IdType::new)
    }
}

impl ::protobuf::Clear for IdType {
    fn clear(&mut self) {
        self.IBAN.clear();
        self.Othr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DbtrType {
    // message fields
    pub PstlAdr: ::protobuf::SingularPtrField<PstlAdrType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DbtrType {
    fn default() -> &'a DbtrType {
        <DbtrType as ::protobuf::Message>::default_instance()
    }
}

impl DbtrType {
    pub fn new() -> DbtrType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.PstlAdrType PstlAdr = 1;


    pub fn get_PstlAdr(&self) -> &PstlAdrType {
        self.PstlAdr.as_ref().unwrap_or_else(|| <PstlAdrType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PstlAdr(&mut self) {
        self.PstlAdr.clear();
    }

    pub fn has_PstlAdr(&self) -> bool {
        self.PstlAdr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PstlAdr(&mut self, v: PstlAdrType) {
        self.PstlAdr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PstlAdr(&mut self) -> &mut PstlAdrType {
        if self.PstlAdr.is_none() {
            self.PstlAdr.set_default();
        }
        self.PstlAdr.as_mut().unwrap()
    }

    // Take field
    pub fn take_PstlAdr(&mut self) -> PstlAdrType {
        self.PstlAdr.take().unwrap_or_else(|| PstlAdrType::new())
    }
}

impl ::protobuf::Message for DbtrType {
    fn is_initialized(&self) -> bool {
        for v in &self.PstlAdr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PstlAdr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.PstlAdr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.PstlAdr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DbtrType {
        DbtrType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PstlAdrType>>(
                "PstlAdr",
                |m: &DbtrType| { &m.PstlAdr },
                |m: &mut DbtrType| { &mut m.PstlAdr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DbtrType>(
                "DbtrType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DbtrType {
        static instance: ::protobuf::rt::LazyV2<DbtrType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DbtrType::new)
    }
}

impl ::protobuf::Clear for DbtrType {
    fn clear(&mut self) {
        self.PstlAdr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DbtrType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DbtrType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PstlAdrType {
    // message fields
    pub AdrLine: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PstlAdrType {
    fn default() -> &'a PstlAdrType {
        <PstlAdrType as ::protobuf::Message>::default_instance()
    }
}

impl PstlAdrType {
    pub fn new() -> PstlAdrType {
        ::std::default::Default::default()
    }

    // repeated string AdrLine = 1;


    pub fn get_AdrLine(&self) -> &[::std::string::String] {
        &self.AdrLine
    }
    pub fn clear_AdrLine(&mut self) {
        self.AdrLine.clear();
    }

    // Param is passed by value, moved
    pub fn set_AdrLine(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.AdrLine = v;
    }

    // Mutable pointer to the field.
    pub fn mut_AdrLine(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.AdrLine
    }

    // Take field
    pub fn take_AdrLine(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.AdrLine, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PstlAdrType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.AdrLine)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.AdrLine {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.AdrLine {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PstlAdrType {
        PstlAdrType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "AdrLine",
                |m: &PstlAdrType| { &m.AdrLine },
                |m: &mut PstlAdrType| { &mut m.AdrLine },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PstlAdrType>(
                "PstlAdrType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PstlAdrType {
        static instance: ::protobuf::rt::LazyV2<PstlAdrType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PstlAdrType::new)
    }
}

impl ::protobuf::Clear for PstlAdrType {
    fn clear(&mut self) {
        self.AdrLine.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PstlAdrType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PstlAdrType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstdAgtType {
    // message fields
    pub FinInstnId: ::protobuf::SingularPtrField<FinInstnIdType4>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstdAgtType {
    fn default() -> &'a InstdAgtType {
        <InstdAgtType as ::protobuf::Message>::default_instance()
    }
}

impl InstdAgtType {
    pub fn new() -> InstdAgtType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.FinInstnIdType4 FinInstnId = 1;


    pub fn get_FinInstnId(&self) -> &FinInstnIdType4 {
        self.FinInstnId.as_ref().unwrap_or_else(|| <FinInstnIdType4 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_FinInstnId(&mut self) {
        self.FinInstnId.clear();
    }

    pub fn has_FinInstnId(&self) -> bool {
        self.FinInstnId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FinInstnId(&mut self, v: FinInstnIdType4) {
        self.FinInstnId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FinInstnId(&mut self) -> &mut FinInstnIdType4 {
        if self.FinInstnId.is_none() {
            self.FinInstnId.set_default();
        }
        self.FinInstnId.as_mut().unwrap()
    }

    // Take field
    pub fn take_FinInstnId(&mut self) -> FinInstnIdType4 {
        self.FinInstnId.take().unwrap_or_else(|| FinInstnIdType4::new())
    }
}

impl ::protobuf::Message for InstdAgtType {
    fn is_initialized(&self) -> bool {
        for v in &self.FinInstnId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.FinInstnId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.FinInstnId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.FinInstnId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstdAgtType {
        InstdAgtType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FinInstnIdType4>>(
                "FinInstnId",
                |m: &InstdAgtType| { &m.FinInstnId },
                |m: &mut InstdAgtType| { &mut m.FinInstnId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstdAgtType>(
                "InstdAgtType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstdAgtType {
        static instance: ::protobuf::rt::LazyV2<InstdAgtType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstdAgtType::new)
    }
}

impl ::protobuf::Clear for InstdAgtType {
    fn clear(&mut self) {
        self.FinInstnId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstdAgtType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstdAgtType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinInstnIdType4 {
    // message fields
    pub Othr: ::protobuf::SingularPtrField<OthrType2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinInstnIdType4 {
    fn default() -> &'a FinInstnIdType4 {
        <FinInstnIdType4 as ::protobuf::Message>::default_instance()
    }
}

impl FinInstnIdType4 {
    pub fn new() -> FinInstnIdType4 {
        ::std::default::Default::default()
    }

    // .protobuf.payment.OthrType2 Othr = 1;


    pub fn get_Othr(&self) -> &OthrType2 {
        self.Othr.as_ref().unwrap_or_else(|| <OthrType2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Othr(&mut self) {
        self.Othr.clear();
    }

    pub fn has_Othr(&self) -> bool {
        self.Othr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Othr(&mut self, v: OthrType2) {
        self.Othr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Othr(&mut self) -> &mut OthrType2 {
        if self.Othr.is_none() {
            self.Othr.set_default();
        }
        self.Othr.as_mut().unwrap()
    }

    // Take field
    pub fn take_Othr(&mut self) -> OthrType2 {
        self.Othr.take().unwrap_or_else(|| OthrType2::new())
    }
}

impl ::protobuf::Message for FinInstnIdType4 {
    fn is_initialized(&self) -> bool {
        for v in &self.Othr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Othr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Othr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Othr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinInstnIdType4 {
        FinInstnIdType4::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OthrType2>>(
                "Othr",
                |m: &FinInstnIdType4| { &m.Othr },
                |m: &mut FinInstnIdType4| { &mut m.Othr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinInstnIdType4>(
                "FinInstnIdType4",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinInstnIdType4 {
        static instance: ::protobuf::rt::LazyV2<FinInstnIdType4> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinInstnIdType4::new)
    }
}

impl ::protobuf::Clear for FinInstnIdType4 {
    fn clear(&mut self) {
        self.Othr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinInstnIdType4 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinInstnIdType4 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstgAgtType {
    // message fields
    pub FinInstnId: ::protobuf::SingularPtrField<FinInstnIdType3>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstgAgtType {
    fn default() -> &'a InstgAgtType {
        <InstgAgtType as ::protobuf::Message>::default_instance()
    }
}

impl InstgAgtType {
    pub fn new() -> InstgAgtType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.FinInstnIdType3 FinInstnId = 1;


    pub fn get_FinInstnId(&self) -> &FinInstnIdType3 {
        self.FinInstnId.as_ref().unwrap_or_else(|| <FinInstnIdType3 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_FinInstnId(&mut self) {
        self.FinInstnId.clear();
    }

    pub fn has_FinInstnId(&self) -> bool {
        self.FinInstnId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FinInstnId(&mut self, v: FinInstnIdType3) {
        self.FinInstnId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FinInstnId(&mut self) -> &mut FinInstnIdType3 {
        if self.FinInstnId.is_none() {
            self.FinInstnId.set_default();
        }
        self.FinInstnId.as_mut().unwrap()
    }

    // Take field
    pub fn take_FinInstnId(&mut self) -> FinInstnIdType3 {
        self.FinInstnId.take().unwrap_or_else(|| FinInstnIdType3::new())
    }
}

impl ::protobuf::Message for InstgAgtType {
    fn is_initialized(&self) -> bool {
        for v in &self.FinInstnId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.FinInstnId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.FinInstnId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.FinInstnId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstgAgtType {
        InstgAgtType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FinInstnIdType3>>(
                "FinInstnId",
                |m: &InstgAgtType| { &m.FinInstnId },
                |m: &mut InstgAgtType| { &mut m.FinInstnId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstgAgtType>(
                "InstgAgtType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstgAgtType {
        static instance: ::protobuf::rt::LazyV2<InstgAgtType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstgAgtType::new)
    }
}

impl ::protobuf::Clear for InstgAgtType {
    fn clear(&mut self) {
        self.FinInstnId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstgAgtType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstgAgtType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinInstnIdType3 {
    // message fields
    pub ClrSysMmbId: ::protobuf::SingularPtrField<ClrSysMmbIdType>,
    pub Othr: ::protobuf::SingularPtrField<OthrType2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinInstnIdType3 {
    fn default() -> &'a FinInstnIdType3 {
        <FinInstnIdType3 as ::protobuf::Message>::default_instance()
    }
}

impl FinInstnIdType3 {
    pub fn new() -> FinInstnIdType3 {
        ::std::default::Default::default()
    }

    // .protobuf.payment.ClrSysMmbIdType ClrSysMmbId = 2;


    pub fn get_ClrSysMmbId(&self) -> &ClrSysMmbIdType {
        self.ClrSysMmbId.as_ref().unwrap_or_else(|| <ClrSysMmbIdType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ClrSysMmbId(&mut self) {
        self.ClrSysMmbId.clear();
    }

    pub fn has_ClrSysMmbId(&self) -> bool {
        self.ClrSysMmbId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ClrSysMmbId(&mut self, v: ClrSysMmbIdType) {
        self.ClrSysMmbId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ClrSysMmbId(&mut self) -> &mut ClrSysMmbIdType {
        if self.ClrSysMmbId.is_none() {
            self.ClrSysMmbId.set_default();
        }
        self.ClrSysMmbId.as_mut().unwrap()
    }

    // Take field
    pub fn take_ClrSysMmbId(&mut self) -> ClrSysMmbIdType {
        self.ClrSysMmbId.take().unwrap_or_else(|| ClrSysMmbIdType::new())
    }

    // .protobuf.payment.OthrType2 Othr = 3;


    pub fn get_Othr(&self) -> &OthrType2 {
        self.Othr.as_ref().unwrap_or_else(|| <OthrType2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Othr(&mut self) {
        self.Othr.clear();
    }

    pub fn has_Othr(&self) -> bool {
        self.Othr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Othr(&mut self, v: OthrType2) {
        self.Othr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Othr(&mut self) -> &mut OthrType2 {
        if self.Othr.is_none() {
            self.Othr.set_default();
        }
        self.Othr.as_mut().unwrap()
    }

    // Take field
    pub fn take_Othr(&mut self) -> OthrType2 {
        self.Othr.take().unwrap_or_else(|| OthrType2::new())
    }
}

impl ::protobuf::Message for FinInstnIdType3 {
    fn is_initialized(&self) -> bool {
        for v in &self.ClrSysMmbId {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Othr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ClrSysMmbId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Othr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ClrSysMmbId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Othr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ClrSysMmbId.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Othr.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinInstnIdType3 {
        FinInstnIdType3::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClrSysMmbIdType>>(
                "ClrSysMmbId",
                |m: &FinInstnIdType3| { &m.ClrSysMmbId },
                |m: &mut FinInstnIdType3| { &mut m.ClrSysMmbId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OthrType2>>(
                "Othr",
                |m: &FinInstnIdType3| { &m.Othr },
                |m: &mut FinInstnIdType3| { &mut m.Othr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinInstnIdType3>(
                "FinInstnIdType3",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinInstnIdType3 {
        static instance: ::protobuf::rt::LazyV2<FinInstnIdType3> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinInstnIdType3::new)
    }
}

impl ::protobuf::Clear for FinInstnIdType3 {
    fn clear(&mut self) {
        self.ClrSysMmbId.clear();
        self.Othr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinInstnIdType3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinInstnIdType3 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OthrType2 {
    // message fields
    pub Id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OthrType2 {
    fn default() -> &'a OthrType2 {
        <OthrType2 as ::protobuf::Message>::default_instance()
    }
}

impl OthrType2 {
    pub fn new() -> OthrType2 {
        ::std::default::Default::default()
    }

    // string Id = 1;


    pub fn get_Id(&self) -> &str {
        &self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id.clear();
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: ::std::string::String) {
        self.Id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Id(&mut self) -> &mut ::std::string::String {
        &mut self.Id
    }

    // Take field
    pub fn take_Id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OthrType2 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Id.is_empty() {
            os.write_string(1, &self.Id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OthrType2 {
        OthrType2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Id",
                |m: &OthrType2| { &m.Id },
                |m: &mut OthrType2| { &mut m.Id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OthrType2>(
                "OthrType2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OthrType2 {
        static instance: ::protobuf::rt::LazyV2<OthrType2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OthrType2::new)
    }
}

impl ::protobuf::Clear for OthrType2 {
    fn clear(&mut self) {
        self.Id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OthrType2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OthrType2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChrgsInfType {
    // message fields
    pub Amt: ::protobuf::SingularPtrField<CurrencyAndAmountType>,
    pub Agt: ::protobuf::SingularPtrField<AgtType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChrgsInfType {
    fn default() -> &'a ChrgsInfType {
        <ChrgsInfType as ::protobuf::Message>::default_instance()
    }
}

impl ChrgsInfType {
    pub fn new() -> ChrgsInfType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.CurrencyAndAmountType Amt = 1;


    pub fn get_Amt(&self) -> &CurrencyAndAmountType {
        self.Amt.as_ref().unwrap_or_else(|| <CurrencyAndAmountType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Amt(&mut self) {
        self.Amt.clear();
    }

    pub fn has_Amt(&self) -> bool {
        self.Amt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Amt(&mut self, v: CurrencyAndAmountType) {
        self.Amt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Amt(&mut self) -> &mut CurrencyAndAmountType {
        if self.Amt.is_none() {
            self.Amt.set_default();
        }
        self.Amt.as_mut().unwrap()
    }

    // Take field
    pub fn take_Amt(&mut self) -> CurrencyAndAmountType {
        self.Amt.take().unwrap_or_else(|| CurrencyAndAmountType::new())
    }

    // .protobuf.payment.AgtType Agt = 2;


    pub fn get_Agt(&self) -> &AgtType {
        self.Agt.as_ref().unwrap_or_else(|| <AgtType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Agt(&mut self) {
        self.Agt.clear();
    }

    pub fn has_Agt(&self) -> bool {
        self.Agt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Agt(&mut self, v: AgtType) {
        self.Agt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Agt(&mut self) -> &mut AgtType {
        if self.Agt.is_none() {
            self.Agt.set_default();
        }
        self.Agt.as_mut().unwrap()
    }

    // Take field
    pub fn take_Agt(&mut self) -> AgtType {
        self.Agt.take().unwrap_or_else(|| AgtType::new())
    }
}

impl ::protobuf::Message for ChrgsInfType {
    fn is_initialized(&self) -> bool {
        for v in &self.Amt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Agt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Amt)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Agt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Amt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Agt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Amt.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Agt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChrgsInfType {
        ChrgsInfType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CurrencyAndAmountType>>(
                "Amt",
                |m: &ChrgsInfType| { &m.Amt },
                |m: &mut ChrgsInfType| { &mut m.Amt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AgtType>>(
                "Agt",
                |m: &ChrgsInfType| { &m.Agt },
                |m: &mut ChrgsInfType| { &mut m.Agt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChrgsInfType>(
                "ChrgsInfType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChrgsInfType {
        static instance: ::protobuf::rt::LazyV2<ChrgsInfType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChrgsInfType::new)
    }
}

impl ::protobuf::Clear for ChrgsInfType {
    fn clear(&mut self) {
        self.Amt.clear();
        self.Agt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChrgsInfType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChrgsInfType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AgtType {
    // message fields
    pub FinInstnId: ::protobuf::SingularPtrField<FinInstnIdType2>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AgtType {
    fn default() -> &'a AgtType {
        <AgtType as ::protobuf::Message>::default_instance()
    }
}

impl AgtType {
    pub fn new() -> AgtType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.FinInstnIdType2 FinInstnId = 1;


    pub fn get_FinInstnId(&self) -> &FinInstnIdType2 {
        self.FinInstnId.as_ref().unwrap_or_else(|| <FinInstnIdType2 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_FinInstnId(&mut self) {
        self.FinInstnId.clear();
    }

    pub fn has_FinInstnId(&self) -> bool {
        self.FinInstnId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FinInstnId(&mut self, v: FinInstnIdType2) {
        self.FinInstnId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FinInstnId(&mut self) -> &mut FinInstnIdType2 {
        if self.FinInstnId.is_none() {
            self.FinInstnId.set_default();
        }
        self.FinInstnId.as_mut().unwrap()
    }

    // Take field
    pub fn take_FinInstnId(&mut self) -> FinInstnIdType2 {
        self.FinInstnId.take().unwrap_or_else(|| FinInstnIdType2::new())
    }
}

impl ::protobuf::Message for AgtType {
    fn is_initialized(&self) -> bool {
        for v in &self.FinInstnId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.FinInstnId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.FinInstnId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.FinInstnId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AgtType {
        AgtType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FinInstnIdType2>>(
                "FinInstnId",
                |m: &AgtType| { &m.FinInstnId },
                |m: &mut AgtType| { &mut m.FinInstnId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AgtType>(
                "AgtType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AgtType {
        static instance: ::protobuf::rt::LazyV2<AgtType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AgtType::new)
    }
}

impl ::protobuf::Clear for AgtType {
    fn clear(&mut self) {
        self.FinInstnId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AgtType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AgtType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinInstnIdType2 {
    // message fields
    pub BICFI: ::std::string::String,
    pub ClrSysMmbId: ::protobuf::SingularPtrField<ClrSysMmbIdType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinInstnIdType2 {
    fn default() -> &'a FinInstnIdType2 {
        <FinInstnIdType2 as ::protobuf::Message>::default_instance()
    }
}

impl FinInstnIdType2 {
    pub fn new() -> FinInstnIdType2 {
        ::std::default::Default::default()
    }

    // string BICFI = 1;


    pub fn get_BICFI(&self) -> &str {
        &self.BICFI
    }
    pub fn clear_BICFI(&mut self) {
        self.BICFI.clear();
    }

    // Param is passed by value, moved
    pub fn set_BICFI(&mut self, v: ::std::string::String) {
        self.BICFI = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_BICFI(&mut self) -> &mut ::std::string::String {
        &mut self.BICFI
    }

    // Take field
    pub fn take_BICFI(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.BICFI, ::std::string::String::new())
    }

    // .protobuf.payment.ClrSysMmbIdType ClrSysMmbId = 2;


    pub fn get_ClrSysMmbId(&self) -> &ClrSysMmbIdType {
        self.ClrSysMmbId.as_ref().unwrap_or_else(|| <ClrSysMmbIdType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ClrSysMmbId(&mut self) {
        self.ClrSysMmbId.clear();
    }

    pub fn has_ClrSysMmbId(&self) -> bool {
        self.ClrSysMmbId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ClrSysMmbId(&mut self, v: ClrSysMmbIdType) {
        self.ClrSysMmbId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ClrSysMmbId(&mut self) -> &mut ClrSysMmbIdType {
        if self.ClrSysMmbId.is_none() {
            self.ClrSysMmbId.set_default();
        }
        self.ClrSysMmbId.as_mut().unwrap()
    }

    // Take field
    pub fn take_ClrSysMmbId(&mut self) -> ClrSysMmbIdType {
        self.ClrSysMmbId.take().unwrap_or_else(|| ClrSysMmbIdType::new())
    }
}

impl ::protobuf::Message for FinInstnIdType2 {
    fn is_initialized(&self) -> bool {
        for v in &self.ClrSysMmbId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.BICFI)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ClrSysMmbId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.BICFI.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.BICFI);
        }
        if let Some(ref v) = self.ClrSysMmbId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.BICFI.is_empty() {
            os.write_string(1, &self.BICFI)?;
        }
        if let Some(ref v) = self.ClrSysMmbId.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinInstnIdType2 {
        FinInstnIdType2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "BICFI",
                |m: &FinInstnIdType2| { &m.BICFI },
                |m: &mut FinInstnIdType2| { &mut m.BICFI },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClrSysMmbIdType>>(
                "ClrSysMmbId",
                |m: &FinInstnIdType2| { &m.ClrSysMmbId },
                |m: &mut FinInstnIdType2| { &mut m.ClrSysMmbId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinInstnIdType2>(
                "FinInstnIdType2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinInstnIdType2 {
        static instance: ::protobuf::rt::LazyV2<FinInstnIdType2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinInstnIdType2::new)
    }
}

impl ::protobuf::Clear for FinInstnIdType2 {
    fn clear(&mut self) {
        self.BICFI.clear();
        self.ClrSysMmbId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinInstnIdType2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinInstnIdType2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinInstnIdType5 {
    // message fields
    pub ClrSysMmbId: ::protobuf::SingularPtrField<ClrSysMmbIdType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinInstnIdType5 {
    fn default() -> &'a FinInstnIdType5 {
        <FinInstnIdType5 as ::protobuf::Message>::default_instance()
    }
}

impl FinInstnIdType5 {
    pub fn new() -> FinInstnIdType5 {
        ::std::default::Default::default()
    }

    // .protobuf.payment.ClrSysMmbIdType ClrSysMmbId = 2;


    pub fn get_ClrSysMmbId(&self) -> &ClrSysMmbIdType {
        self.ClrSysMmbId.as_ref().unwrap_or_else(|| <ClrSysMmbIdType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ClrSysMmbId(&mut self) {
        self.ClrSysMmbId.clear();
    }

    pub fn has_ClrSysMmbId(&self) -> bool {
        self.ClrSysMmbId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ClrSysMmbId(&mut self, v: ClrSysMmbIdType) {
        self.ClrSysMmbId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ClrSysMmbId(&mut self) -> &mut ClrSysMmbIdType {
        if self.ClrSysMmbId.is_none() {
            self.ClrSysMmbId.set_default();
        }
        self.ClrSysMmbId.as_mut().unwrap()
    }

    // Take field
    pub fn take_ClrSysMmbId(&mut self) -> ClrSysMmbIdType {
        self.ClrSysMmbId.take().unwrap_or_else(|| ClrSysMmbIdType::new())
    }
}

impl ::protobuf::Message for FinInstnIdType5 {
    fn is_initialized(&self) -> bool {
        for v in &self.ClrSysMmbId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ClrSysMmbId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ClrSysMmbId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ClrSysMmbId.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinInstnIdType5 {
        FinInstnIdType5::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClrSysMmbIdType>>(
                "ClrSysMmbId",
                |m: &FinInstnIdType5| { &m.ClrSysMmbId },
                |m: &mut FinInstnIdType5| { &mut m.ClrSysMmbId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinInstnIdType5>(
                "FinInstnIdType5",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinInstnIdType5 {
        static instance: ::protobuf::rt::LazyV2<FinInstnIdType5> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinInstnIdType5::new)
    }
}

impl ::protobuf::Clear for FinInstnIdType5 {
    fn clear(&mut self) {
        self.ClrSysMmbId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinInstnIdType5 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinInstnIdType5 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClrSysMmbIdType {
    // message fields
    pub ClrSysId: ::protobuf::SingularPtrField<ClrSysIdType>,
    pub MmbId: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClrSysMmbIdType {
    fn default() -> &'a ClrSysMmbIdType {
        <ClrSysMmbIdType as ::protobuf::Message>::default_instance()
    }
}

impl ClrSysMmbIdType {
    pub fn new() -> ClrSysMmbIdType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.ClrSysIdType ClrSysId = 1;


    pub fn get_ClrSysId(&self) -> &ClrSysIdType {
        self.ClrSysId.as_ref().unwrap_or_else(|| <ClrSysIdType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ClrSysId(&mut self) {
        self.ClrSysId.clear();
    }

    pub fn has_ClrSysId(&self) -> bool {
        self.ClrSysId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ClrSysId(&mut self, v: ClrSysIdType) {
        self.ClrSysId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ClrSysId(&mut self) -> &mut ClrSysIdType {
        if self.ClrSysId.is_none() {
            self.ClrSysId.set_default();
        }
        self.ClrSysId.as_mut().unwrap()
    }

    // Take field
    pub fn take_ClrSysId(&mut self) -> ClrSysIdType {
        self.ClrSysId.take().unwrap_or_else(|| ClrSysIdType::new())
    }

    // string MmbId = 2;


    pub fn get_MmbId(&self) -> &str {
        &self.MmbId
    }
    pub fn clear_MmbId(&mut self) {
        self.MmbId.clear();
    }

    // Param is passed by value, moved
    pub fn set_MmbId(&mut self, v: ::std::string::String) {
        self.MmbId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_MmbId(&mut self) -> &mut ::std::string::String {
        &mut self.MmbId
    }

    // Take field
    pub fn take_MmbId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.MmbId, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClrSysMmbIdType {
    fn is_initialized(&self) -> bool {
        for v in &self.ClrSysId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ClrSysId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.MmbId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ClrSysId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.MmbId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.MmbId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ClrSysId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.MmbId.is_empty() {
            os.write_string(2, &self.MmbId)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClrSysMmbIdType {
        ClrSysMmbIdType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClrSysIdType>>(
                "ClrSysId",
                |m: &ClrSysMmbIdType| { &m.ClrSysId },
                |m: &mut ClrSysMmbIdType| { &mut m.ClrSysId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "MmbId",
                |m: &ClrSysMmbIdType| { &m.MmbId },
                |m: &mut ClrSysMmbIdType| { &mut m.MmbId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClrSysMmbIdType>(
                "ClrSysMmbIdType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClrSysMmbIdType {
        static instance: ::protobuf::rt::LazyV2<ClrSysMmbIdType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClrSysMmbIdType::new)
    }
}

impl ::protobuf::Clear for ClrSysMmbIdType {
    fn clear(&mut self) {
        self.ClrSysId.clear();
        self.MmbId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClrSysMmbIdType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClrSysMmbIdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClrSysIdType {
    // message fields
    pub Cd: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClrSysIdType {
    fn default() -> &'a ClrSysIdType {
        <ClrSysIdType as ::protobuf::Message>::default_instance()
    }
}

impl ClrSysIdType {
    pub fn new() -> ClrSysIdType {
        ::std::default::Default::default()
    }

    // string Cd = 1;


    pub fn get_Cd(&self) -> &str {
        &self.Cd
    }
    pub fn clear_Cd(&mut self) {
        self.Cd.clear();
    }

    // Param is passed by value, moved
    pub fn set_Cd(&mut self, v: ::std::string::String) {
        self.Cd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Cd(&mut self) -> &mut ::std::string::String {
        &mut self.Cd
    }

    // Take field
    pub fn take_Cd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Cd, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClrSysIdType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Cd)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Cd.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Cd);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Cd.is_empty() {
            os.write_string(1, &self.Cd)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClrSysIdType {
        ClrSysIdType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Cd",
                |m: &ClrSysIdType| { &m.Cd },
                |m: &mut ClrSysIdType| { &mut m.Cd },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClrSysIdType>(
                "ClrSysIdType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClrSysIdType {
        static instance: ::protobuf::rt::LazyV2<ClrSysIdType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClrSysIdType::new)
    }
}

impl ::protobuf::Clear for ClrSysIdType {
    fn clear(&mut self) {
        self.Cd.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClrSysIdType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClrSysIdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CurrencyAndAmountType {
    // message fields
    pub Ccy: ::std::string::String,
    pub Amt: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CurrencyAndAmountType {
    fn default() -> &'a CurrencyAndAmountType {
        <CurrencyAndAmountType as ::protobuf::Message>::default_instance()
    }
}

impl CurrencyAndAmountType {
    pub fn new() -> CurrencyAndAmountType {
        ::std::default::Default::default()
    }

    // string Ccy = 1;


    pub fn get_Ccy(&self) -> &str {
        &self.Ccy
    }
    pub fn clear_Ccy(&mut self) {
        self.Ccy.clear();
    }

    // Param is passed by value, moved
    pub fn set_Ccy(&mut self, v: ::std::string::String) {
        self.Ccy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Ccy(&mut self) -> &mut ::std::string::String {
        &mut self.Ccy
    }

    // Take field
    pub fn take_Ccy(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Ccy, ::std::string::String::new())
    }

    // string Amt = 2;


    pub fn get_Amt(&self) -> &str {
        &self.Amt
    }
    pub fn clear_Amt(&mut self) {
        self.Amt.clear();
    }

    // Param is passed by value, moved
    pub fn set_Amt(&mut self, v: ::std::string::String) {
        self.Amt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Amt(&mut self) -> &mut ::std::string::String {
        &mut self.Amt
    }

    // Take field
    pub fn take_Amt(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Amt, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CurrencyAndAmountType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Ccy)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Amt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Ccy.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Ccy);
        }
        if !self.Amt.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.Amt);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Ccy.is_empty() {
            os.write_string(1, &self.Ccy)?;
        }
        if !self.Amt.is_empty() {
            os.write_string(2, &self.Amt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CurrencyAndAmountType {
        CurrencyAndAmountType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Ccy",
                |m: &CurrencyAndAmountType| { &m.Ccy },
                |m: &mut CurrencyAndAmountType| { &mut m.Ccy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Amt",
                |m: &CurrencyAndAmountType| { &m.Amt },
                |m: &mut CurrencyAndAmountType| { &mut m.Amt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CurrencyAndAmountType>(
                "CurrencyAndAmountType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CurrencyAndAmountType {
        static instance: ::protobuf::rt::LazyV2<CurrencyAndAmountType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CurrencyAndAmountType::new)
    }
}

impl ::protobuf::Clear for CurrencyAndAmountType {
    fn clear(&mut self) {
        self.Ccy.clear();
        self.Amt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CurrencyAndAmountType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CurrencyAndAmountType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PmtTpInfType2 {
    // message fields
    pub SvcLvl: ::protobuf::SingularPtrField<SvcLvlType>,
    pub LclInstrm: ::protobuf::SingularPtrField<LclInstrmType>,
    pub CtgyPurp: ::protobuf::SingularPtrField<CtgyPurpType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PmtTpInfType2 {
    fn default() -> &'a PmtTpInfType2 {
        <PmtTpInfType2 as ::protobuf::Message>::default_instance()
    }
}

impl PmtTpInfType2 {
    pub fn new() -> PmtTpInfType2 {
        ::std::default::Default::default()
    }

    // .protobuf.payment.SvcLvlType SvcLvl = 1;


    pub fn get_SvcLvl(&self) -> &SvcLvlType {
        self.SvcLvl.as_ref().unwrap_or_else(|| <SvcLvlType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SvcLvl(&mut self) {
        self.SvcLvl.clear();
    }

    pub fn has_SvcLvl(&self) -> bool {
        self.SvcLvl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SvcLvl(&mut self, v: SvcLvlType) {
        self.SvcLvl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SvcLvl(&mut self) -> &mut SvcLvlType {
        if self.SvcLvl.is_none() {
            self.SvcLvl.set_default();
        }
        self.SvcLvl.as_mut().unwrap()
    }

    // Take field
    pub fn take_SvcLvl(&mut self) -> SvcLvlType {
        self.SvcLvl.take().unwrap_or_else(|| SvcLvlType::new())
    }

    // .protobuf.payment.LclInstrmType LclInstrm = 2;


    pub fn get_LclInstrm(&self) -> &LclInstrmType {
        self.LclInstrm.as_ref().unwrap_or_else(|| <LclInstrmType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_LclInstrm(&mut self) {
        self.LclInstrm.clear();
    }

    pub fn has_LclInstrm(&self) -> bool {
        self.LclInstrm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_LclInstrm(&mut self, v: LclInstrmType) {
        self.LclInstrm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_LclInstrm(&mut self) -> &mut LclInstrmType {
        if self.LclInstrm.is_none() {
            self.LclInstrm.set_default();
        }
        self.LclInstrm.as_mut().unwrap()
    }

    // Take field
    pub fn take_LclInstrm(&mut self) -> LclInstrmType {
        self.LclInstrm.take().unwrap_or_else(|| LclInstrmType::new())
    }

    // .protobuf.payment.CtgyPurpType CtgyPurp = 3;


    pub fn get_CtgyPurp(&self) -> &CtgyPurpType {
        self.CtgyPurp.as_ref().unwrap_or_else(|| <CtgyPurpType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_CtgyPurp(&mut self) {
        self.CtgyPurp.clear();
    }

    pub fn has_CtgyPurp(&self) -> bool {
        self.CtgyPurp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CtgyPurp(&mut self, v: CtgyPurpType) {
        self.CtgyPurp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CtgyPurp(&mut self) -> &mut CtgyPurpType {
        if self.CtgyPurp.is_none() {
            self.CtgyPurp.set_default();
        }
        self.CtgyPurp.as_mut().unwrap()
    }

    // Take field
    pub fn take_CtgyPurp(&mut self) -> CtgyPurpType {
        self.CtgyPurp.take().unwrap_or_else(|| CtgyPurpType::new())
    }
}

impl ::protobuf::Message for PmtTpInfType2 {
    fn is_initialized(&self) -> bool {
        for v in &self.SvcLvl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.LclInstrm {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CtgyPurp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SvcLvl)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.LclInstrm)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CtgyPurp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.SvcLvl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.LclInstrm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.CtgyPurp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.SvcLvl.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.LclInstrm.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.CtgyPurp.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PmtTpInfType2 {
        PmtTpInfType2::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SvcLvlType>>(
                "SvcLvl",
                |m: &PmtTpInfType2| { &m.SvcLvl },
                |m: &mut PmtTpInfType2| { &mut m.SvcLvl },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LclInstrmType>>(
                "LclInstrm",
                |m: &PmtTpInfType2| { &m.LclInstrm },
                |m: &mut PmtTpInfType2| { &mut m.LclInstrm },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CtgyPurpType>>(
                "CtgyPurp",
                |m: &PmtTpInfType2| { &m.CtgyPurp },
                |m: &mut PmtTpInfType2| { &mut m.CtgyPurp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PmtTpInfType2>(
                "PmtTpInfType2",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PmtTpInfType2 {
        static instance: ::protobuf::rt::LazyV2<PmtTpInfType2> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PmtTpInfType2::new)
    }
}

impl ::protobuf::Clear for PmtTpInfType2 {
    fn clear(&mut self) {
        self.SvcLvl.clear();
        self.LclInstrm.clear();
        self.CtgyPurp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PmtTpInfType2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PmtTpInfType2 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LclInstrmType {
    // message fields
    pub Prtry: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LclInstrmType {
    fn default() -> &'a LclInstrmType {
        <LclInstrmType as ::protobuf::Message>::default_instance()
    }
}

impl LclInstrmType {
    pub fn new() -> LclInstrmType {
        ::std::default::Default::default()
    }

    // string Prtry = 1;


    pub fn get_Prtry(&self) -> &str {
        &self.Prtry
    }
    pub fn clear_Prtry(&mut self) {
        self.Prtry.clear();
    }

    // Param is passed by value, moved
    pub fn set_Prtry(&mut self, v: ::std::string::String) {
        self.Prtry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Prtry(&mut self) -> &mut ::std::string::String {
        &mut self.Prtry
    }

    // Take field
    pub fn take_Prtry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Prtry, ::std::string::String::new())
    }
}

impl ::protobuf::Message for LclInstrmType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Prtry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Prtry.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Prtry);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Prtry.is_empty() {
            os.write_string(1, &self.Prtry)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LclInstrmType {
        LclInstrmType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Prtry",
                |m: &LclInstrmType| { &m.Prtry },
                |m: &mut LclInstrmType| { &mut m.Prtry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LclInstrmType>(
                "LclInstrmType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LclInstrmType {
        static instance: ::protobuf::rt::LazyV2<LclInstrmType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LclInstrmType::new)
    }
}

impl ::protobuf::Clear for LclInstrmType {
    fn clear(&mut self) {
        self.Prtry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LclInstrmType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LclInstrmType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SvcLvlType {
    // message fields
    pub Prtry: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SvcLvlType {
    fn default() -> &'a SvcLvlType {
        <SvcLvlType as ::protobuf::Message>::default_instance()
    }
}

impl SvcLvlType {
    pub fn new() -> SvcLvlType {
        ::std::default::Default::default()
    }

    // string Prtry = 1;


    pub fn get_Prtry(&self) -> &str {
        &self.Prtry
    }
    pub fn clear_Prtry(&mut self) {
        self.Prtry.clear();
    }

    // Param is passed by value, moved
    pub fn set_Prtry(&mut self, v: ::std::string::String) {
        self.Prtry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Prtry(&mut self) -> &mut ::std::string::String {
        &mut self.Prtry
    }

    // Take field
    pub fn take_Prtry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Prtry, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SvcLvlType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Prtry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Prtry.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Prtry);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Prtry.is_empty() {
            os.write_string(1, &self.Prtry)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SvcLvlType {
        SvcLvlType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Prtry",
                |m: &SvcLvlType| { &m.Prtry },
                |m: &mut SvcLvlType| { &mut m.Prtry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SvcLvlType>(
                "SvcLvlType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SvcLvlType {
        static instance: ::protobuf::rt::LazyV2<SvcLvlType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SvcLvlType::new)
    }
}

impl ::protobuf::Clear for SvcLvlType {
    fn clear(&mut self) {
        self.Prtry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SvcLvlType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SvcLvlType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PmtIdType {
    // message fields
    pub EndToEndId: ::std::string::String,
    pub TxId: ::std::string::String,
    pub ClrSysRef: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PmtIdType {
    fn default() -> &'a PmtIdType {
        <PmtIdType as ::protobuf::Message>::default_instance()
    }
}

impl PmtIdType {
    pub fn new() -> PmtIdType {
        ::std::default::Default::default()
    }

    // string EndToEndId = 1;


    pub fn get_EndToEndId(&self) -> &str {
        &self.EndToEndId
    }
    pub fn clear_EndToEndId(&mut self) {
        self.EndToEndId.clear();
    }

    // Param is passed by value, moved
    pub fn set_EndToEndId(&mut self, v: ::std::string::String) {
        self.EndToEndId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_EndToEndId(&mut self) -> &mut ::std::string::String {
        &mut self.EndToEndId
    }

    // Take field
    pub fn take_EndToEndId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.EndToEndId, ::std::string::String::new())
    }

    // string TxId = 2;


    pub fn get_TxId(&self) -> &str {
        &self.TxId
    }
    pub fn clear_TxId(&mut self) {
        self.TxId.clear();
    }

    // Param is passed by value, moved
    pub fn set_TxId(&mut self, v: ::std::string::String) {
        self.TxId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_TxId(&mut self) -> &mut ::std::string::String {
        &mut self.TxId
    }

    // Take field
    pub fn take_TxId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.TxId, ::std::string::String::new())
    }

    // string ClrSysRef = 3;


    pub fn get_ClrSysRef(&self) -> &str {
        &self.ClrSysRef
    }
    pub fn clear_ClrSysRef(&mut self) {
        self.ClrSysRef.clear();
    }

    // Param is passed by value, moved
    pub fn set_ClrSysRef(&mut self, v: ::std::string::String) {
        self.ClrSysRef = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ClrSysRef(&mut self) -> &mut ::std::string::String {
        &mut self.ClrSysRef
    }

    // Take field
    pub fn take_ClrSysRef(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ClrSysRef, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PmtIdType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.EndToEndId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.TxId)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ClrSysRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.EndToEndId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.EndToEndId);
        }
        if !self.TxId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.TxId);
        }
        if !self.ClrSysRef.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ClrSysRef);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.EndToEndId.is_empty() {
            os.write_string(1, &self.EndToEndId)?;
        }
        if !self.TxId.is_empty() {
            os.write_string(2, &self.TxId)?;
        }
        if !self.ClrSysRef.is_empty() {
            os.write_string(3, &self.ClrSysRef)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PmtIdType {
        PmtIdType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "EndToEndId",
                |m: &PmtIdType| { &m.EndToEndId },
                |m: &mut PmtIdType| { &mut m.EndToEndId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "TxId",
                |m: &PmtIdType| { &m.TxId },
                |m: &mut PmtIdType| { &mut m.TxId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ClrSysRef",
                |m: &PmtIdType| { &m.ClrSysRef },
                |m: &mut PmtIdType| { &mut m.ClrSysRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PmtIdType>(
                "PmtIdType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PmtIdType {
        static instance: ::protobuf::rt::LazyV2<PmtIdType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PmtIdType::new)
    }
}

impl ::protobuf::Clear for PmtIdType {
    fn clear(&mut self) {
        self.EndToEndId.clear();
        self.TxId.clear();
        self.ClrSysRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PmtIdType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PmtIdType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GrpHdrType {
    // message fields
    pub MsgId: ::std::string::String,
    pub CreDtTm: ::std::string::String,
    pub NbOfTxs: ::std::string::String,
    pub SttlmInf: ::protobuf::SingularPtrField<SttlmInfType>,
    pub PmtTpInf: ::protobuf::SingularPtrField<PmtTpInfType1>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GrpHdrType {
    fn default() -> &'a GrpHdrType {
        <GrpHdrType as ::protobuf::Message>::default_instance()
    }
}

impl GrpHdrType {
    pub fn new() -> GrpHdrType {
        ::std::default::Default::default()
    }

    // string MsgId = 1;


    pub fn get_MsgId(&self) -> &str {
        &self.MsgId
    }
    pub fn clear_MsgId(&mut self) {
        self.MsgId.clear();
    }

    // Param is passed by value, moved
    pub fn set_MsgId(&mut self, v: ::std::string::String) {
        self.MsgId = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_MsgId(&mut self) -> &mut ::std::string::String {
        &mut self.MsgId
    }

    // Take field
    pub fn take_MsgId(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.MsgId, ::std::string::String::new())
    }

    // string CreDtTm = 2;


    pub fn get_CreDtTm(&self) -> &str {
        &self.CreDtTm
    }
    pub fn clear_CreDtTm(&mut self) {
        self.CreDtTm.clear();
    }

    // Param is passed by value, moved
    pub fn set_CreDtTm(&mut self, v: ::std::string::String) {
        self.CreDtTm = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CreDtTm(&mut self) -> &mut ::std::string::String {
        &mut self.CreDtTm
    }

    // Take field
    pub fn take_CreDtTm(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.CreDtTm, ::std::string::String::new())
    }

    // string NbOfTxs = 3;


    pub fn get_NbOfTxs(&self) -> &str {
        &self.NbOfTxs
    }
    pub fn clear_NbOfTxs(&mut self) {
        self.NbOfTxs.clear();
    }

    // Param is passed by value, moved
    pub fn set_NbOfTxs(&mut self, v: ::std::string::String) {
        self.NbOfTxs = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_NbOfTxs(&mut self) -> &mut ::std::string::String {
        &mut self.NbOfTxs
    }

    // Take field
    pub fn take_NbOfTxs(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.NbOfTxs, ::std::string::String::new())
    }

    // .protobuf.payment.SttlmInfType SttlmInf = 4;


    pub fn get_SttlmInf(&self) -> &SttlmInfType {
        self.SttlmInf.as_ref().unwrap_or_else(|| <SttlmInfType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SttlmInf(&mut self) {
        self.SttlmInf.clear();
    }

    pub fn has_SttlmInf(&self) -> bool {
        self.SttlmInf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SttlmInf(&mut self, v: SttlmInfType) {
        self.SttlmInf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SttlmInf(&mut self) -> &mut SttlmInfType {
        if self.SttlmInf.is_none() {
            self.SttlmInf.set_default();
        }
        self.SttlmInf.as_mut().unwrap()
    }

    // Take field
    pub fn take_SttlmInf(&mut self) -> SttlmInfType {
        self.SttlmInf.take().unwrap_or_else(|| SttlmInfType::new())
    }

    // .protobuf.payment.PmtTpInfType1 PmtTpInf = 5;


    pub fn get_PmtTpInf(&self) -> &PmtTpInfType1 {
        self.PmtTpInf.as_ref().unwrap_or_else(|| <PmtTpInfType1 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_PmtTpInf(&mut self) {
        self.PmtTpInf.clear();
    }

    pub fn has_PmtTpInf(&self) -> bool {
        self.PmtTpInf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_PmtTpInf(&mut self, v: PmtTpInfType1) {
        self.PmtTpInf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PmtTpInf(&mut self) -> &mut PmtTpInfType1 {
        if self.PmtTpInf.is_none() {
            self.PmtTpInf.set_default();
        }
        self.PmtTpInf.as_mut().unwrap()
    }

    // Take field
    pub fn take_PmtTpInf(&mut self) -> PmtTpInfType1 {
        self.PmtTpInf.take().unwrap_or_else(|| PmtTpInfType1::new())
    }
}

impl ::protobuf::Message for GrpHdrType {
    fn is_initialized(&self) -> bool {
        for v in &self.SttlmInf {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.PmtTpInf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.MsgId)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.CreDtTm)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.NbOfTxs)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SttlmInf)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.PmtTpInf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.MsgId.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.MsgId);
        }
        if !self.CreDtTm.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.CreDtTm);
        }
        if !self.NbOfTxs.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.NbOfTxs);
        }
        if let Some(ref v) = self.SttlmInf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.PmtTpInf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.MsgId.is_empty() {
            os.write_string(1, &self.MsgId)?;
        }
        if !self.CreDtTm.is_empty() {
            os.write_string(2, &self.CreDtTm)?;
        }
        if !self.NbOfTxs.is_empty() {
            os.write_string(3, &self.NbOfTxs)?;
        }
        if let Some(ref v) = self.SttlmInf.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.PmtTpInf.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GrpHdrType {
        GrpHdrType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "MsgId",
                |m: &GrpHdrType| { &m.MsgId },
                |m: &mut GrpHdrType| { &mut m.MsgId },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "CreDtTm",
                |m: &GrpHdrType| { &m.CreDtTm },
                |m: &mut GrpHdrType| { &mut m.CreDtTm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "NbOfTxs",
                |m: &GrpHdrType| { &m.NbOfTxs },
                |m: &mut GrpHdrType| { &mut m.NbOfTxs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SttlmInfType>>(
                "SttlmInf",
                |m: &GrpHdrType| { &m.SttlmInf },
                |m: &mut GrpHdrType| { &mut m.SttlmInf },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PmtTpInfType1>>(
                "PmtTpInf",
                |m: &GrpHdrType| { &m.PmtTpInf },
                |m: &mut GrpHdrType| { &mut m.PmtTpInf },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GrpHdrType>(
                "GrpHdrType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GrpHdrType {
        static instance: ::protobuf::rt::LazyV2<GrpHdrType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GrpHdrType::new)
    }
}

impl ::protobuf::Clear for GrpHdrType {
    fn clear(&mut self) {
        self.MsgId.clear();
        self.CreDtTm.clear();
        self.NbOfTxs.clear();
        self.SttlmInf.clear();
        self.PmtTpInf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GrpHdrType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GrpHdrType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SttlmInfType {
    // message fields
    pub SttlmMtd: ::std::string::String,
    pub ClrSys: ::protobuf::SingularPtrField<ClrSysType>,
    pub InstgRmbrsmntAgt: ::protobuf::SingularPtrField<InstRmbrsmntAgtType>,
    pub InstdRmbrsmntAgt: ::protobuf::SingularPtrField<InstRmbrsmntAgtType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SttlmInfType {
    fn default() -> &'a SttlmInfType {
        <SttlmInfType as ::protobuf::Message>::default_instance()
    }
}

impl SttlmInfType {
    pub fn new() -> SttlmInfType {
        ::std::default::Default::default()
    }

    // string SttlmMtd = 1;


    pub fn get_SttlmMtd(&self) -> &str {
        &self.SttlmMtd
    }
    pub fn clear_SttlmMtd(&mut self) {
        self.SttlmMtd.clear();
    }

    // Param is passed by value, moved
    pub fn set_SttlmMtd(&mut self, v: ::std::string::String) {
        self.SttlmMtd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SttlmMtd(&mut self) -> &mut ::std::string::String {
        &mut self.SttlmMtd
    }

    // Take field
    pub fn take_SttlmMtd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.SttlmMtd, ::std::string::String::new())
    }

    // .protobuf.payment.ClrSysType ClrSys = 2;


    pub fn get_ClrSys(&self) -> &ClrSysType {
        self.ClrSys.as_ref().unwrap_or_else(|| <ClrSysType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ClrSys(&mut self) {
        self.ClrSys.clear();
    }

    pub fn has_ClrSys(&self) -> bool {
        self.ClrSys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ClrSys(&mut self, v: ClrSysType) {
        self.ClrSys = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ClrSys(&mut self) -> &mut ClrSysType {
        if self.ClrSys.is_none() {
            self.ClrSys.set_default();
        }
        self.ClrSys.as_mut().unwrap()
    }

    // Take field
    pub fn take_ClrSys(&mut self) -> ClrSysType {
        self.ClrSys.take().unwrap_or_else(|| ClrSysType::new())
    }

    // .protobuf.payment.InstRmbrsmntAgtType InstgRmbrsmntAgt = 3;


    pub fn get_InstgRmbrsmntAgt(&self) -> &InstRmbrsmntAgtType {
        self.InstgRmbrsmntAgt.as_ref().unwrap_or_else(|| <InstRmbrsmntAgtType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_InstgRmbrsmntAgt(&mut self) {
        self.InstgRmbrsmntAgt.clear();
    }

    pub fn has_InstgRmbrsmntAgt(&self) -> bool {
        self.InstgRmbrsmntAgt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InstgRmbrsmntAgt(&mut self, v: InstRmbrsmntAgtType) {
        self.InstgRmbrsmntAgt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_InstgRmbrsmntAgt(&mut self) -> &mut InstRmbrsmntAgtType {
        if self.InstgRmbrsmntAgt.is_none() {
            self.InstgRmbrsmntAgt.set_default();
        }
        self.InstgRmbrsmntAgt.as_mut().unwrap()
    }

    // Take field
    pub fn take_InstgRmbrsmntAgt(&mut self) -> InstRmbrsmntAgtType {
        self.InstgRmbrsmntAgt.take().unwrap_or_else(|| InstRmbrsmntAgtType::new())
    }

    // .protobuf.payment.InstRmbrsmntAgtType InstdRmbrsmntAgt = 4;


    pub fn get_InstdRmbrsmntAgt(&self) -> &InstRmbrsmntAgtType {
        self.InstdRmbrsmntAgt.as_ref().unwrap_or_else(|| <InstRmbrsmntAgtType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_InstdRmbrsmntAgt(&mut self) {
        self.InstdRmbrsmntAgt.clear();
    }

    pub fn has_InstdRmbrsmntAgt(&self) -> bool {
        self.InstdRmbrsmntAgt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_InstdRmbrsmntAgt(&mut self, v: InstRmbrsmntAgtType) {
        self.InstdRmbrsmntAgt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_InstdRmbrsmntAgt(&mut self) -> &mut InstRmbrsmntAgtType {
        if self.InstdRmbrsmntAgt.is_none() {
            self.InstdRmbrsmntAgt.set_default();
        }
        self.InstdRmbrsmntAgt.as_mut().unwrap()
    }

    // Take field
    pub fn take_InstdRmbrsmntAgt(&mut self) -> InstRmbrsmntAgtType {
        self.InstdRmbrsmntAgt.take().unwrap_or_else(|| InstRmbrsmntAgtType::new())
    }
}

impl ::protobuf::Message for SttlmInfType {
    fn is_initialized(&self) -> bool {
        for v in &self.ClrSys {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.InstgRmbrsmntAgt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.InstdRmbrsmntAgt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.SttlmMtd)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ClrSys)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.InstgRmbrsmntAgt)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.InstdRmbrsmntAgt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.SttlmMtd.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.SttlmMtd);
        }
        if let Some(ref v) = self.ClrSys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.InstgRmbrsmntAgt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.InstdRmbrsmntAgt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.SttlmMtd.is_empty() {
            os.write_string(1, &self.SttlmMtd)?;
        }
        if let Some(ref v) = self.ClrSys.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.InstgRmbrsmntAgt.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.InstdRmbrsmntAgt.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SttlmInfType {
        SttlmInfType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "SttlmMtd",
                |m: &SttlmInfType| { &m.SttlmMtd },
                |m: &mut SttlmInfType| { &mut m.SttlmMtd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClrSysType>>(
                "ClrSys",
                |m: &SttlmInfType| { &m.ClrSys },
                |m: &mut SttlmInfType| { &mut m.ClrSys },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstRmbrsmntAgtType>>(
                "InstgRmbrsmntAgt",
                |m: &SttlmInfType| { &m.InstgRmbrsmntAgt },
                |m: &mut SttlmInfType| { &mut m.InstgRmbrsmntAgt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstRmbrsmntAgtType>>(
                "InstdRmbrsmntAgt",
                |m: &SttlmInfType| { &m.InstdRmbrsmntAgt },
                |m: &mut SttlmInfType| { &mut m.InstdRmbrsmntAgt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SttlmInfType>(
                "SttlmInfType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SttlmInfType {
        static instance: ::protobuf::rt::LazyV2<SttlmInfType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SttlmInfType::new)
    }
}

impl ::protobuf::Clear for SttlmInfType {
    fn clear(&mut self) {
        self.SttlmMtd.clear();
        self.ClrSys.clear();
        self.InstgRmbrsmntAgt.clear();
        self.InstdRmbrsmntAgt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SttlmInfType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SttlmInfType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClrSysType {
    // message fields
    pub Prtry: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClrSysType {
    fn default() -> &'a ClrSysType {
        <ClrSysType as ::protobuf::Message>::default_instance()
    }
}

impl ClrSysType {
    pub fn new() -> ClrSysType {
        ::std::default::Default::default()
    }

    // string Prtry = 1;


    pub fn get_Prtry(&self) -> &str {
        &self.Prtry
    }
    pub fn clear_Prtry(&mut self) {
        self.Prtry.clear();
    }

    // Param is passed by value, moved
    pub fn set_Prtry(&mut self, v: ::std::string::String) {
        self.Prtry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Prtry(&mut self) -> &mut ::std::string::String {
        &mut self.Prtry
    }

    // Take field
    pub fn take_Prtry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Prtry, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClrSysType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Prtry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Prtry.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Prtry);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Prtry.is_empty() {
            os.write_string(1, &self.Prtry)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClrSysType {
        ClrSysType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Prtry",
                |m: &ClrSysType| { &m.Prtry },
                |m: &mut ClrSysType| { &mut m.Prtry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClrSysType>(
                "ClrSysType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClrSysType {
        static instance: ::protobuf::rt::LazyV2<ClrSysType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClrSysType::new)
    }
}

impl ::protobuf::Clear for ClrSysType {
    fn clear(&mut self) {
        self.Prtry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClrSysType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClrSysType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstRmbrsmntAgtType {
    // message fields
    pub FinInstnId: ::protobuf::SingularPtrField<FinInstnIdType1>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstRmbrsmntAgtType {
    fn default() -> &'a InstRmbrsmntAgtType {
        <InstRmbrsmntAgtType as ::protobuf::Message>::default_instance()
    }
}

impl InstRmbrsmntAgtType {
    pub fn new() -> InstRmbrsmntAgtType {
        ::std::default::Default::default()
    }

    // .protobuf.payment.FinInstnIdType1 FinInstnId = 1;


    pub fn get_FinInstnId(&self) -> &FinInstnIdType1 {
        self.FinInstnId.as_ref().unwrap_or_else(|| <FinInstnIdType1 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_FinInstnId(&mut self) {
        self.FinInstnId.clear();
    }

    pub fn has_FinInstnId(&self) -> bool {
        self.FinInstnId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_FinInstnId(&mut self, v: FinInstnIdType1) {
        self.FinInstnId = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_FinInstnId(&mut self) -> &mut FinInstnIdType1 {
        if self.FinInstnId.is_none() {
            self.FinInstnId.set_default();
        }
        self.FinInstnId.as_mut().unwrap()
    }

    // Take field
    pub fn take_FinInstnId(&mut self) -> FinInstnIdType1 {
        self.FinInstnId.take().unwrap_or_else(|| FinInstnIdType1::new())
    }
}

impl ::protobuf::Message for InstRmbrsmntAgtType {
    fn is_initialized(&self) -> bool {
        for v in &self.FinInstnId {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.FinInstnId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.FinInstnId.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.FinInstnId.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstRmbrsmntAgtType {
        InstRmbrsmntAgtType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FinInstnIdType1>>(
                "FinInstnId",
                |m: &InstRmbrsmntAgtType| { &m.FinInstnId },
                |m: &mut InstRmbrsmntAgtType| { &mut m.FinInstnId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstRmbrsmntAgtType>(
                "InstRmbrsmntAgtType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstRmbrsmntAgtType {
        static instance: ::protobuf::rt::LazyV2<InstRmbrsmntAgtType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstRmbrsmntAgtType::new)
    }
}

impl ::protobuf::Clear for InstRmbrsmntAgtType {
    fn clear(&mut self) {
        self.FinInstnId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstRmbrsmntAgtType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstRmbrsmntAgtType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FinInstnIdType1 {
    // message fields
    pub Othr: ::protobuf::SingularPtrField<OthrType>,
    pub SchmeNm: ::protobuf::SingularPtrField<SchmeNmType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FinInstnIdType1 {
    fn default() -> &'a FinInstnIdType1 {
        <FinInstnIdType1 as ::protobuf::Message>::default_instance()
    }
}

impl FinInstnIdType1 {
    pub fn new() -> FinInstnIdType1 {
        ::std::default::Default::default()
    }

    // .protobuf.payment.OthrType Othr = 1;


    pub fn get_Othr(&self) -> &OthrType {
        self.Othr.as_ref().unwrap_or_else(|| <OthrType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Othr(&mut self) {
        self.Othr.clear();
    }

    pub fn has_Othr(&self) -> bool {
        self.Othr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Othr(&mut self, v: OthrType) {
        self.Othr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Othr(&mut self) -> &mut OthrType {
        if self.Othr.is_none() {
            self.Othr.set_default();
        }
        self.Othr.as_mut().unwrap()
    }

    // Take field
    pub fn take_Othr(&mut self) -> OthrType {
        self.Othr.take().unwrap_or_else(|| OthrType::new())
    }

    // .protobuf.payment.SchmeNmType SchmeNm = 2;


    pub fn get_SchmeNm(&self) -> &SchmeNmType {
        self.SchmeNm.as_ref().unwrap_or_else(|| <SchmeNmType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SchmeNm(&mut self) {
        self.SchmeNm.clear();
    }

    pub fn has_SchmeNm(&self) -> bool {
        self.SchmeNm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SchmeNm(&mut self, v: SchmeNmType) {
        self.SchmeNm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SchmeNm(&mut self) -> &mut SchmeNmType {
        if self.SchmeNm.is_none() {
            self.SchmeNm.set_default();
        }
        self.SchmeNm.as_mut().unwrap()
    }

    // Take field
    pub fn take_SchmeNm(&mut self) -> SchmeNmType {
        self.SchmeNm.take().unwrap_or_else(|| SchmeNmType::new())
    }
}

impl ::protobuf::Message for FinInstnIdType1 {
    fn is_initialized(&self) -> bool {
        for v in &self.Othr {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.SchmeNm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Othr)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SchmeNm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Othr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.SchmeNm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Othr.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.SchmeNm.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FinInstnIdType1 {
        FinInstnIdType1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OthrType>>(
                "Othr",
                |m: &FinInstnIdType1| { &m.Othr },
                |m: &mut FinInstnIdType1| { &mut m.Othr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SchmeNmType>>(
                "SchmeNm",
                |m: &FinInstnIdType1| { &m.SchmeNm },
                |m: &mut FinInstnIdType1| { &mut m.SchmeNm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FinInstnIdType1>(
                "FinInstnIdType1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FinInstnIdType1 {
        static instance: ::protobuf::rt::LazyV2<FinInstnIdType1> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FinInstnIdType1::new)
    }
}

impl ::protobuf::Clear for FinInstnIdType1 {
    fn clear(&mut self) {
        self.Othr.clear();
        self.SchmeNm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FinInstnIdType1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FinInstnIdType1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OthrType {
    // message fields
    pub Id: ::std::string::String,
    pub SchmeNm: ::protobuf::SingularPtrField<SchmeNmType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OthrType {
    fn default() -> &'a OthrType {
        <OthrType as ::protobuf::Message>::default_instance()
    }
}

impl OthrType {
    pub fn new() -> OthrType {
        ::std::default::Default::default()
    }

    // string Id = 1;


    pub fn get_Id(&self) -> &str {
        &self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id.clear();
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: ::std::string::String) {
        self.Id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Id(&mut self) -> &mut ::std::string::String {
        &mut self.Id
    }

    // Take field
    pub fn take_Id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Id, ::std::string::String::new())
    }

    // .protobuf.payment.SchmeNmType SchmeNm = 2;


    pub fn get_SchmeNm(&self) -> &SchmeNmType {
        self.SchmeNm.as_ref().unwrap_or_else(|| <SchmeNmType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_SchmeNm(&mut self) {
        self.SchmeNm.clear();
    }

    pub fn has_SchmeNm(&self) -> bool {
        self.SchmeNm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_SchmeNm(&mut self, v: SchmeNmType) {
        self.SchmeNm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_SchmeNm(&mut self) -> &mut SchmeNmType {
        if self.SchmeNm.is_none() {
            self.SchmeNm.set_default();
        }
        self.SchmeNm.as_mut().unwrap()
    }

    // Take field
    pub fn take_SchmeNm(&mut self) -> SchmeNmType {
        self.SchmeNm.take().unwrap_or_else(|| SchmeNmType::new())
    }
}

impl ::protobuf::Message for OthrType {
    fn is_initialized(&self) -> bool {
        for v in &self.SchmeNm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.SchmeNm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Id);
        }
        if let Some(ref v) = self.SchmeNm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Id.is_empty() {
            os.write_string(1, &self.Id)?;
        }
        if let Some(ref v) = self.SchmeNm.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OthrType {
        OthrType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Id",
                |m: &OthrType| { &m.Id },
                |m: &mut OthrType| { &mut m.Id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SchmeNmType>>(
                "SchmeNm",
                |m: &OthrType| { &m.SchmeNm },
                |m: &mut OthrType| { &mut m.SchmeNm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OthrType>(
                "OthrType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OthrType {
        static instance: ::protobuf::rt::LazyV2<OthrType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OthrType::new)
    }
}

impl ::protobuf::Clear for OthrType {
    fn clear(&mut self) {
        self.Id.clear();
        self.SchmeNm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OthrType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OthrType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SchmeNmType {
    // message fields
    pub Prtry: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SchmeNmType {
    fn default() -> &'a SchmeNmType {
        <SchmeNmType as ::protobuf::Message>::default_instance()
    }
}

impl SchmeNmType {
    pub fn new() -> SchmeNmType {
        ::std::default::Default::default()
    }

    // string Prtry = 1;


    pub fn get_Prtry(&self) -> &str {
        &self.Prtry
    }
    pub fn clear_Prtry(&mut self) {
        self.Prtry.clear();
    }

    // Param is passed by value, moved
    pub fn set_Prtry(&mut self, v: ::std::string::String) {
        self.Prtry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Prtry(&mut self) -> &mut ::std::string::String {
        &mut self.Prtry
    }

    // Take field
    pub fn take_Prtry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Prtry, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SchmeNmType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Prtry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Prtry.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Prtry);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Prtry.is_empty() {
            os.write_string(1, &self.Prtry)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SchmeNmType {
        SchmeNmType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Prtry",
                |m: &SchmeNmType| { &m.Prtry },
                |m: &mut SchmeNmType| { &mut m.Prtry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SchmeNmType>(
                "SchmeNmType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SchmeNmType {
        static instance: ::protobuf::rt::LazyV2<SchmeNmType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SchmeNmType::new)
    }
}

impl ::protobuf::Clear for SchmeNmType {
    fn clear(&mut self) {
        self.Prtry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SchmeNmType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SchmeNmType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PmtTpInfType1 {
    // message fields
    pub CtgyPurp: ::protobuf::SingularPtrField<CtgyPurpType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PmtTpInfType1 {
    fn default() -> &'a PmtTpInfType1 {
        <PmtTpInfType1 as ::protobuf::Message>::default_instance()
    }
}

impl PmtTpInfType1 {
    pub fn new() -> PmtTpInfType1 {
        ::std::default::Default::default()
    }

    // .protobuf.payment.CtgyPurpType CtgyPurp = 1;


    pub fn get_CtgyPurp(&self) -> &CtgyPurpType {
        self.CtgyPurp.as_ref().unwrap_or_else(|| <CtgyPurpType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_CtgyPurp(&mut self) {
        self.CtgyPurp.clear();
    }

    pub fn has_CtgyPurp(&self) -> bool {
        self.CtgyPurp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CtgyPurp(&mut self, v: CtgyPurpType) {
        self.CtgyPurp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CtgyPurp(&mut self) -> &mut CtgyPurpType {
        if self.CtgyPurp.is_none() {
            self.CtgyPurp.set_default();
        }
        self.CtgyPurp.as_mut().unwrap()
    }

    // Take field
    pub fn take_CtgyPurp(&mut self) -> CtgyPurpType {
        self.CtgyPurp.take().unwrap_or_else(|| CtgyPurpType::new())
    }
}

impl ::protobuf::Message for PmtTpInfType1 {
    fn is_initialized(&self) -> bool {
        for v in &self.CtgyPurp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CtgyPurp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.CtgyPurp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.CtgyPurp.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PmtTpInfType1 {
        PmtTpInfType1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CtgyPurpType>>(
                "CtgyPurp",
                |m: &PmtTpInfType1| { &m.CtgyPurp },
                |m: &mut PmtTpInfType1| { &mut m.CtgyPurp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PmtTpInfType1>(
                "PmtTpInfType1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PmtTpInfType1 {
        static instance: ::protobuf::rt::LazyV2<PmtTpInfType1> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PmtTpInfType1::new)
    }
}

impl ::protobuf::Clear for PmtTpInfType1 {
    fn clear(&mut self) {
        self.CtgyPurp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PmtTpInfType1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PmtTpInfType1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CtgyPurpType {
    // message fields
    pub Prtry: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CtgyPurpType {
    fn default() -> &'a CtgyPurpType {
        <CtgyPurpType as ::protobuf::Message>::default_instance()
    }
}

impl CtgyPurpType {
    pub fn new() -> CtgyPurpType {
        ::std::default::Default::default()
    }

    // string Prtry = 1;


    pub fn get_Prtry(&self) -> &str {
        &self.Prtry
    }
    pub fn clear_Prtry(&mut self) {
        self.Prtry.clear();
    }

    // Param is passed by value, moved
    pub fn set_Prtry(&mut self, v: ::std::string::String) {
        self.Prtry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Prtry(&mut self) -> &mut ::std::string::String {
        &mut self.Prtry
    }

    // Take field
    pub fn take_Prtry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.Prtry, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CtgyPurpType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.Prtry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.Prtry.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.Prtry);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.Prtry.is_empty() {
            os.write_string(1, &self.Prtry)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CtgyPurpType {
        CtgyPurpType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "Prtry",
                |m: &CtgyPurpType| { &m.Prtry },
                |m: &mut CtgyPurpType| { &mut m.Prtry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CtgyPurpType>(
                "CtgyPurpType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CtgyPurpType {
        static instance: ::protobuf::rt::LazyV2<CtgyPurpType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CtgyPurpType::new)
    }
}

impl ::protobuf::Clear for CtgyPurpType {
    fn clear(&mut self) {
        self.Prtry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CtgyPurpType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CtgyPurpType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1dpayment_pacs_008_001_06.proto\x12\x10protobuf.payment\"h\n\x0fPacs\
    _008_001_06\x12U\n\x11FIToFICstmrCdtTrf\x18\x01\x20\x01(\x0b2'.protobuf.\
    payment.FIToFICstmrCdtTrfTypeR\x11FIToFICstmrCdtTrf\"\x92\x01\n\x15FIToF\
    ICstmrCdtTrfType\x124\n\x06GrpHdr\x18\x01\x20\x01(\x0b2\x1c.protobuf.pay\
    ment.GrpHdrTypeR\x06GrpHdr\x12C\n\x0bCdtTrfTxInf\x18\x02\x20\x01(\x0b2!.\
    protobuf.payment.CdtTrfTxInfTypeR\x0bCdtTrfTxInf\"\xb9\x08\n\x0fCdtTrfTx\
    InfType\x121\n\x05PmtId\x18\x01\x20\x01(\x0b2\x1b.protobuf.payment.PmtId\
    TypeR\x05PmtId\x12;\n\x08PmtTpInf\x18\x02\x20\x01(\x0b2\x1f.protobuf.pay\
    ment.PmtTpInfType2R\x08PmtTpInf\x12O\n\x0eIntrBkSttlmAmt\x18\x03\x20\x01\
    (\x0b2'.protobuf.payment.CurrencyAndAmountTypeR\x0eIntrBkSttlmAmt\x12$\n\
    \rIntrBkSttlmDt\x18\x04\x20\x01(\tR\rIntrBkSttlmDt\x12\x20\n\x0bAccptncD\
    tTm\x18\x05\x20\x01(\tR\x0bAccptncDtTm\x12C\n\x08InstdAmt\x18\x06\x20\
    \x01(\x0b2'.protobuf.payment.CurrencyAndAmountTypeR\x08InstdAmt\x12\x1a\
    \n\x08XchgRate\x18\x07\x20\x01(\tR\x08XchgRate\x12\x16\n\x06ChrgBr\x18\
    \x08\x20\x01(\tR\x06ChrgBr\x12:\n\x08ChrgsInf\x18\t\x20\x01(\x0b2\x1e.pr\
    otobuf.payment.ChrgsInfTypeR\x08ChrgsInf\x12:\n\x08InstgAgt\x18\n\x20\
    \x01(\x0b2\x1e.protobuf.payment.InstgAgtTypeR\x08InstgAgt\x12:\n\x08Inst\
    dAgt\x18\x0b\x20\x01(\x0b2\x1e.protobuf.payment.InstdAgtTypeR\x08InstdAg\
    t\x12.\n\x04Dbtr\x18\x0c\x20\x01(\x0b2\x1a.protobuf.payment.DbtrTypeR\
    \x04Dbtr\x12:\n\x08DbtrAcct\x18\r\x20\x01(\x0b2\x1e.protobuf.payment.Dbt\
    rAcctTypeR\x08DbtrAcct\x127\n\x07DbtrAgt\x18\x0e\x20\x01(\x0b2\x1d.proto\
    buf.payment.DbtrAgtTypeR\x07DbtrAgt\x127\n\x07CdtrAgt\x18\x0f\x20\x01(\
    \x0b2\x1d.protobuf.payment.CdtrAgtTypeR\x07CdtrAgt\x12.\n\x04Cdtr\x18\
    \x10\x20\x01(\x0b2\x1a.protobuf.payment.CdtrTypeR\x04Cdtr\x12:\n\x08Cdtr\
    Acct\x18\x11\x20\x01(\x0b2\x1e.protobuf.payment.CdtrAcctTypeR\x08CdtrAcc\
    t\x12.\n\x04Purp\x18\x12\x20\x01(\x0b2\x1a.protobuf.payment.PurpTypeR\
    \x04Purp\x12@\n\nRgltryRptg\x18\x13\x20\x01(\x0b2\x20.protobuf.payment.R\
    gltryRptgTypeR\nRgltryRptg\x124\n\x06RmtInf\x18\x14\x20\x01(\x0b2\x1c.pr\
    otobuf.payment.RmtInfTypeR\x06RmtInf\"R\n\nRmtInfType\x12\x14\n\x05Ustrd\
    \x18\x01\x20\x01(\tR\x05Ustrd\x12.\n\x04Strd\x18\x02\x20\x01(\x0b2\x1a.p\
    rotobuf.payment.StrdTypeR\x04Strd\"n\n\x08StrdType\x12@\n\nCdtrRefInf\
    \x18\x01\x20\x01(\x0b2\x20.protobuf.payment.CdtrRefInfTypeR\nCdtrRefInf\
    \x12\x20\n\x0bAddtlRmtInf\x18\x02\x20\x03(\tR\x0bAddtlRmtInf\"\"\n\x0eCd\
    trRefInfType\x12\x10\n\x03Ref\x18\x01\x20\x01(\tR\x03Ref\"@\n\x0eRgltryR\
    ptgType\x12.\n\x04Dtls\x18\x01\x20\x01(\x0b2\x1a.protobuf.payment.DtlsTy\
    peR\x04Dtls\"\x1c\n\x08DtlsType\x12\x10\n\x03Inf\x18\x01\x20\x03(\tR\x03\
    Inf\"\x1a\n\x08PurpType\x12\x0e\n\x02Cd\x18\x01\x20\x01(\tR\x02Cd\"s\n\
    \x0cCdtrAcctType\x12)\n\x02Id\x18\x01\x20\x01(\x0b2\x19.protobuf.payment\
    .IdType2R\x02Id\x12(\n\x02Tp\x18\x02\x20\x01(\x0b2\x18.protobuf.payment.\
    TpTypeR\x02Tp\x12\x0e\n\x02Nm\x18\x03\x20\x01(\tR\x02Nm\"\x1e\n\x06TpTyp\
    e\x12\x14\n\x05Prtry\x18\x01\x20\x01(\tR\x05Prtry\":\n\x07IdType2\x12/\n\
    \x04Othr\x18\x01\x20\x01(\x0b2\x1b.protobuf.payment.OthrType2R\x04Othr\"\
    C\n\x08CdtrType\x127\n\x07PstlAdr\x18\x01\x20\x01(\x0b2\x1d.protobuf.pay\
    ment.PstlAdrTypeR\x07PstlAdr\"P\n\x0bCdtrAgtType\x12A\n\nFinInstnId\x18\
    \x01\x20\x01(\x0b2!.protobuf.payment.FinInstnIdType5R\nFinInstnId\"P\n\
    \x0bDbtrAgtType\x12A\n\nFinInstnId\x18\x01\x20\x01(\x0b2!.protobuf.payme\
    nt.FinInstnIdType2R\nFinInstnId\"H\n\x0cDbtrAcctType\x12(\n\x02Id\x18\
    \x01\x20\x01(\x0b2\x18.protobuf.payment.IdTypeR\x02Id\x12\x0e\n\x02Nm\
    \x18\x02\x20\x01(\tR\x02Nm\"M\n\x06IdType\x12\x12\n\x04IBAN\x18\x01\x20\
    \x01(\tR\x04IBAN\x12/\n\x04Othr\x18\x02\x20\x01(\x0b2\x1b.protobuf.payme\
    nt.OthrType2R\x04Othr\"C\n\x08DbtrType\x127\n\x07PstlAdr\x18\x01\x20\x01\
    (\x0b2\x1d.protobuf.payment.PstlAdrTypeR\x07PstlAdr\"'\n\x0bPstlAdrType\
    \x12\x18\n\x07AdrLine\x18\x01\x20\x03(\tR\x07AdrLine\"Q\n\x0cInstdAgtTyp\
    e\x12A\n\nFinInstnId\x18\x01\x20\x01(\x0b2!.protobuf.payment.FinInstnIdT\
    ype4R\nFinInstnId\"B\n\x0fFinInstnIdType4\x12/\n\x04Othr\x18\x01\x20\x01\
    (\x0b2\x1b.protobuf.payment.OthrType2R\x04Othr\"Q\n\x0cInstgAgtType\x12A\
    \n\nFinInstnId\x18\x01\x20\x01(\x0b2!.protobuf.payment.FinInstnIdType3R\
    \nFinInstnId\"\x87\x01\n\x0fFinInstnIdType3\x12C\n\x0bClrSysMmbId\x18\
    \x02\x20\x01(\x0b2!.protobuf.payment.ClrSysMmbIdTypeR\x0bClrSysMmbId\x12\
    /\n\x04Othr\x18\x03\x20\x01(\x0b2\x1b.protobuf.payment.OthrType2R\x04Oth\
    r\"\x1b\n\tOthrType2\x12\x0e\n\x02Id\x18\x01\x20\x01(\tR\x02Id\"v\n\x0cC\
    hrgsInfType\x129\n\x03Amt\x18\x01\x20\x01(\x0b2'.protobuf.payment.Curren\
    cyAndAmountTypeR\x03Amt\x12+\n\x03Agt\x18\x02\x20\x01(\x0b2\x19.protobuf\
    .payment.AgtTypeR\x03Agt\"L\n\x07AgtType\x12A\n\nFinInstnId\x18\x01\x20\
    \x01(\x0b2!.protobuf.payment.FinInstnIdType2R\nFinInstnId\"l\n\x0fFinIns\
    tnIdType2\x12\x14\n\x05BICFI\x18\x01\x20\x01(\tR\x05BICFI\x12C\n\x0bClrS\
    ysMmbId\x18\x02\x20\x01(\x0b2!.protobuf.payment.ClrSysMmbIdTypeR\x0bClrS\
    ysMmbId\"V\n\x0fFinInstnIdType5\x12C\n\x0bClrSysMmbId\x18\x02\x20\x01(\
    \x0b2!.protobuf.payment.ClrSysMmbIdTypeR\x0bClrSysMmbId\"c\n\x0fClrSysMm\
    bIdType\x12:\n\x08ClrSysId\x18\x01\x20\x01(\x0b2\x1e.protobuf.payment.Cl\
    rSysIdTypeR\x08ClrSysId\x12\x14\n\x05MmbId\x18\x02\x20\x01(\tR\x05MmbId\
    \"\x1e\n\x0cClrSysIdType\x12\x0e\n\x02Cd\x18\x01\x20\x01(\tR\x02Cd\";\n\
    \x15CurrencyAndAmountType\x12\x10\n\x03Ccy\x18\x01\x20\x01(\tR\x03Ccy\
    \x12\x10\n\x03Amt\x18\x02\x20\x01(\tR\x03Amt\"\xc0\x01\n\rPmtTpInfType2\
    \x124\n\x06SvcLvl\x18\x01\x20\x01(\x0b2\x1c.protobuf.payment.SvcLvlTypeR\
    \x06SvcLvl\x12=\n\tLclInstrm\x18\x02\x20\x01(\x0b2\x1f.protobuf.payment.\
    LclInstrmTypeR\tLclInstrm\x12:\n\x08CtgyPurp\x18\x03\x20\x01(\x0b2\x1e.p\
    rotobuf.payment.CtgyPurpTypeR\x08CtgyPurp\"%\n\rLclInstrmType\x12\x14\n\
    \x05Prtry\x18\x01\x20\x01(\tR\x05Prtry\"\"\n\nSvcLvlType\x12\x14\n\x05Pr\
    try\x18\x01\x20\x01(\tR\x05Prtry\"]\n\tPmtIdType\x12\x1e\n\nEndToEndId\
    \x18\x01\x20\x01(\tR\nEndToEndId\x12\x12\n\x04TxId\x18\x02\x20\x01(\tR\
    \x04TxId\x12\x1c\n\tClrSysRef\x18\x03\x20\x01(\tR\tClrSysRef\"\xcf\x01\n\
    \nGrpHdrType\x12\x14\n\x05MsgId\x18\x01\x20\x01(\tR\x05MsgId\x12\x18\n\
    \x07CreDtTm\x18\x02\x20\x01(\tR\x07CreDtTm\x12\x18\n\x07NbOfTxs\x18\x03\
    \x20\x01(\tR\x07NbOfTxs\x12:\n\x08SttlmInf\x18\x04\x20\x01(\x0b2\x1e.pro\
    tobuf.payment.SttlmInfTypeR\x08SttlmInf\x12;\n\x08PmtTpInf\x18\x05\x20\
    \x01(\x0b2\x1f.protobuf.payment.PmtTpInfType1R\x08PmtTpInf\"\x86\x02\n\
    \x0cSttlmInfType\x12\x1a\n\x08SttlmMtd\x18\x01\x20\x01(\tR\x08SttlmMtd\
    \x124\n\x06ClrSys\x18\x02\x20\x01(\x0b2\x1c.protobuf.payment.ClrSysTypeR\
    \x06ClrSys\x12Q\n\x10InstgRmbrsmntAgt\x18\x03\x20\x01(\x0b2%.protobuf.pa\
    yment.InstRmbrsmntAgtTypeR\x10InstgRmbrsmntAgt\x12Q\n\x10InstdRmbrsmntAg\
    t\x18\x04\x20\x01(\x0b2%.protobuf.payment.InstRmbrsmntAgtTypeR\x10InstdR\
    mbrsmntAgt\"\"\n\nClrSysType\x12\x14\n\x05Prtry\x18\x01\x20\x01(\tR\x05P\
    rtry\"X\n\x13InstRmbrsmntAgtType\x12A\n\nFinInstnId\x18\x01\x20\x01(\x0b\
    2!.protobuf.payment.FinInstnIdType1R\nFinInstnId\"z\n\x0fFinInstnIdType1\
    \x12.\n\x04Othr\x18\x01\x20\x01(\x0b2\x1a.protobuf.payment.OthrTypeR\x04\
    Othr\x127\n\x07SchmeNm\x18\x02\x20\x01(\x0b2\x1d.protobuf.payment.SchmeN\
    mTypeR\x07SchmeNm\"S\n\x08OthrType\x12\x0e\n\x02Id\x18\x01\x20\x01(\tR\
    \x02Id\x127\n\x07SchmeNm\x18\x02\x20\x01(\x0b2\x1d.protobuf.payment.Schm\
    eNmTypeR\x07SchmeNm\"#\n\x0bSchmeNmType\x12\x14\n\x05Prtry\x18\x01\x20\
    \x01(\tR\x05Prtry\"K\n\rPmtTpInfType1\x12:\n\x08CtgyPurp\x18\x01\x20\x01\
    (\x0b2\x1e.protobuf.payment.CtgyPurpTypeR\x08CtgyPurp\"$\n\x0cCtgyPurpTy\
    pe\x12\x14\n\x05Prtry\x18\x01\x20\x01(\tR\x05PrtryBO\n6uk.co.nationwide.\
    payments.schema.payment.body.iso20022B\x15PaymentPacs008_001_06b\x06prot\
    o3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
